% !TeX program = pdflatex --shell-escape
% !TeX TXS-program:pdflatex --shell-escape

\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{pdflscape}
\usepackage{graphicx}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{minted}
\usepackage{minted}
\usepackage{tikz}

\geometry{left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm}

\definecolor{codebackground}{RGB}{245,245,245}
\definecolor{codekeyword}{RGB}{127,0,85}
\definecolor{codestring}{RGB}{42,0,255}
\definecolor{codecomment}{RGB}{63,127,95}

\tcbuselibrary{listings,skins,breakable}

\newtcblisting{javacode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=java,
    minted options={
        numbers=left,
        numbersep=5pt,
        fontsize=\footnotesize, % Cambiado de \small a \footnotesize
        breaklines=true,
        linenos=true,
        baselinestretch=1.1, % REDUCIDO de 1.0 a 0.8
        tabsize=4,
        frame=lines,
        framesep=2mm
    },
    colback=codebackground,
    colframe=black!70,
    listing only,
    left=5mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries,
    breakable,
    #1
}

\newtcblisting{sqlcode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=sql,
    minted options={
        numbers=left,
        numbersep=5pt,
        fontsize=\footnotesize,
        breaklines=true,
        linenos=true,
        baselinestretch=1.1,
        tabsize=4,
        frame=lines,
        framesep=2mm
    },
    colback=codebackground,
    colframe=black!70,
    listing only,
    left=5mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries,
    breakable,
    #1
}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=black
}

\newcommand{\coursename}{Escuela Profesional de Ingeniería de Sistemas e Informática}
\newcommand{\reportname}{Producto Final de la Segunda Unidad}
\newcommand{\reporttitle}{Sistema de Gestión de Cafetín}
\newcommand{\studentname}{Angiely Nina Choque}
\newcommand{\teachername}{Honorio Apaza Alanoca}
\newcommand{\subjectname}{Programación Orientada a Objetos II}

\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{Pág. \thepage}
\rhead{Universidad Nacional de Moquegua\\\coursename}

\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\centering
\textsc{\Large \textbf{UNIVERSIDAD NACIONAL DE MOQUEGUA}}\\[0.5cm]
\textsc{\Large Facultad de Ingeniería y Arquitectura }\\[0.5cm]
\textsc{\large Escuela Profesional de Ingeniería de Sistemas e Informática}\\[0.8cm]
\includegraphics[scale=.28]{img/logo.png}\\[0.5cm] 
{ 
\Large{\bfseries{\reporttitle}}\\[0.5cm]
\large{\bfseries{\reportname}}
}\\[1.0cm]
\emph{\large Estudiante:}\\[0.2cm]
\studentname\\[0.7cm]
\emph{\large Docente:}\\[0.2cm]
\teachername\\[0.7cm]
\emph{\large Curso:}\\[0.2cm]
\subjectname\\[1.0cm]
{\large \today}\\[1.5cm]
\vfill
\end{titlepage}

\setstretch{1.5}
\setlength{\parindent}{1.27cm}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación y contexto}

El presente proyecto representa el producto final de la segunda unidad de Programación Orientada a Objetos II, donde se integran los conocimientos fundamentales de POO con tecnologías web y bases de datos relacionales. La motivación principal consiste en desarrollar un sistema completo de gestión para un cafetín que resuelva problemáticas reales de negocios de comida, permitiendo la consolidación de conceptos teóricos mediante su implementación práctica en una aplicación web funcional.

\textbf{Problemática identificada:} Los cafetines tradicionales enfrentan diversos desafíos operativos que afectan su eficiencia y rentabilidad. Entre los principales problemas se encuentran: (1) la gestión manual de pedidos que genera errores, pérdida de órdenes y tiempos de espera prolongados; (2) el control deficiente del inventario que resulta en desabastecimiento de productos populares o pérdidas por vencimiento; (3) la ausencia de sistemas de fidelización de clientes que permitan conocer preferencias y generar estrategias de retención; (4) la dificultad para generar reportes de ventas, productos más solicitados y análisis de rentabilidad; y (5) la falta de diferenciación de roles y permisos entre empleados, exponiendo el negocio a riesgos de seguridad.

Este sistema aborda estas problemáticas mediante una solución integral que digitaliza los procesos críticos del negocio. A diferencia del prototipo inicial que trabajaba únicamente con clases en memoria, esta versión incorpora persistencia de datos mediante MySQL, arquitectura MVC (Modelo-Vista-Controlador), y una interfaz web desarrollada con JSP y Servlets. El resultado es una aplicación empresarial escalable que demuestra la aplicación práctica de patrones de diseño y buenas prácticas de desarrollo.

El sistema ``Sistema de Gestión de Cafetín'' permite gestionar tres tipos de usuarios diferenciados mediante herencia: administradores con acceso completo al sistema, cajeros que procesan pedidos, y clientes que realizan compras con un sistema de membresías y puntos de fidelización. Esta diferenciación de roles ejemplifica el uso del polimorfismo y la abstracción en un contexto real, donde cada tipo de usuario tiene comportamientos y permisos específicos, resolviendo así la problemática de control de accesos y permitiendo operaciones seguras y auditables.

\section{Marco Teórico}

\subsection{Programación Orientada a Objetos (POO)}

La Programación Orientada a Objetos es un paradigma de programación que organiza el diseño del software en torno a objetos que contienen tanto datos como comportamientos. Este paradigma se fundamenta en cuatro principios esenciales que permiten crear sistemas modulares, reutilizables y mantenibles \cite{booch2007}. A diferencia de la programación procedural, la POO permite modelar entidades del mundo real de manera más natural y expresiva.

El \textbf{encapsulamiento} consiste en ocultar los detalles internos de implementación de un objeto, exponiendo únicamente una interfaz pública para interactuar con él. En Java, esto se logra mediante modificadores de acceso (private, protected, public) que controlan la visibilidad de atributos y métodos. Este principio mejora la seguridad del código y facilita su mantenimiento, ya que los cambios internos no afectan al código que utiliza la clase.

La \textbf{herencia} es un mecanismo que permite crear nuevas clases basándose en clases existentes, heredando sus atributos y métodos. Esto promueve la reutilización de código y establece relaciones jerárquicas entre clases. En el sistema desarrollado, la clase abstracta Usuario sirve como clase base para Administrador, Cajero y Cliente, compartiendo funcionalidad común mientras permite especializaciones específicas \cite{bloch2018}.

El \textbf{polimorfismo} permite que objetos de diferentes clases respondan al mismo mensaje de manera particular según su tipo. En Java, esto se manifiesta mediante la sobrecarga de métodos (mismo nombre, diferentes parámetros) y la redefinición de métodos heredados. Este principio permite escribir código más flexible y extensible, como se evidencia en los métodos abstractos de la clase Usuario que cada subclase implementa de forma específica.

La \textbf{abstracción} es el proceso de identificar las características esenciales de un objeto, ignorando los detalles irrelevantes para el contexto. Las clases abstractas e interfaces en Java permiten definir contratos de comportamiento sin especificar la implementación, logrando un alto nivel de modularidad y bajo acoplamiento entre componentes \cite{martin2008}.

\subsection{Diagramas UML}

El Lenguaje Unificado de Modelado (UML) es un estándar para visualizar, especificar, construir y documentar artefactos de sistemas software \cite{fowler2003}. Los diagramas de clases son uno de los tipos más importantes de UML, mostrando la estructura estática del sistema mediante clases, atributos, métodos y relaciones.

Un diagrama de clases UML representa cada clase como un rectángulo dividido en tres secciones: nombre de la clase, atributos y métodos. Los modificadores de visibilidad se indican con símbolos: + para público, - para privado, \# para protegido. Las relaciones se representan mediante diferentes tipos de líneas: líneas sólidas para asociaciones, líneas con rombos para agregación y composición, y flechas con líneas continuas para herencia.

Los diagramas UML son fundamentales en las fases de análisis y diseño, permitiendo comunicar la estructura del sistema de forma visual e independiente del lenguaje de programación. Herramientas como PlantUML, draw.io y Mermaid permiten crear estos diagramas mediante código o interfaces gráficas, facilitando su actualización y versionado junto con el código fuente.

\subsection{Relaciones entre Clases en POO}

Las relaciones entre clases definen cómo los objetos interactúan y se conectan entre sí en un sistema orientado a objetos \cite{larman2004}. Existen varios tipos de relaciones, cada una con semántica y consecuencias diferentes en el diseño del sistema.

La \textbf{asociación} es la relación más general, indicando que dos clases están conectadas de alguna manera. Puede ser unidireccional (una clase conoce a la otra) o bidireccional (ambas se conocen mutuamente). Las asociaciones tienen multiplicidad, indicando cuántos objetos de cada clase participan en la relación (uno-a-uno, uno-a-muchos, muchos-a-muchos).

La \textbf{agregación} es un tipo especial de asociación que representa una relación ``todo-parte'' donde las partes pueden existir independientemente del todo. Por ejemplo, un Departamento contiene Empleados, pero los empleados pueden existir aunque se elimine el departamento. Esta relación implica una conexión débil entre los objetos participantes.

La \textbf{composición} es una forma fuerte de agregación donde las partes dependen completamente del todo para su existencia. Si el objeto contenedor se destruye, sus partes también lo hacen. En el sistema desarrollado, la relación entre Pedido y DetallePedido es de composición, ya que los detalles de un pedido no pueden existir sin el pedido que los contiene.

La \textbf{herencia} (también llamada generalización) establece una relación ``es-un'' entre una clase padre y sus clases hijas. Las subclases heredan todos los atributos y métodos de la superclase, pudiendo añadir funcionalidad específica o redefinir comportamientos heredados. Esta relación permite la reutilización de código y el polimorfismo, fundamentales para el diseño flexible de sistemas.

\subsection{MySQL y Bases de Datos Relacionales}

MySQL es un sistema de gestión de bases de datos relacionales (RDBMS) de código abierto ampliamente utilizado en aplicaciones web. Una base de datos relacional organiza la información en tablas relacionadas entre sí mediante claves primarias y foráneas, garantizando la integridad referencial y consistencia de los datos \cite{dubois2013}.

El modelo relacional se basa en la teoría de conjuntos y álgebra relacional, permitiendo realizar consultas complejas mediante SQL (Structured Query Language). Las operaciones básicas incluyen SELECT para consultas, INSERT para inserciones, UPDATE para actualizaciones y DELETE para eliminaciones. MySQL soporta características avanzadas como transacciones ACID, procedimientos almacenados, triggers, y vistas, que permiten implementar lógica compleja directamente en la base de datos \cite{schwartz2012}.

La normalización de bases de datos es un proceso mediante el cual se organizan las tablas para minimizar la redundancia y dependencias. Las formas normales (1FN, 2FN, 3FN) establecen reglas progresivamente más estrictas para el diseño de esquemas, mejorando la integridad y eficiencia de las consultas. El diseño adecuado de índices también es crucial para optimizar el rendimiento de las consultas frecuentes.

\textbf{XAMPP} es una distribución de Apache que incluye MySQL, PHP y Perl, facilitando la instalación y configuración de un entorno de desarrollo web local. Para este proyecto, se utilizó XAMPP para gestionar la base de datos MySQL, proporcionando una interfaz amigable a través de phpMyAdmin para la creación y administración de tablas, ejecución de consultas SQL, y respaldo de datos.

\subsection{Entorno de Desarrollo Java Web}

\subsubsection{Apache NetBeans y Java con Ant}

Apache NetBeans es un entorno de desarrollo integrado (IDE) de código abierto que proporciona herramientas completas para el desarrollo de aplicaciones Java, especialmente para aplicaciones empresariales y web \cite{oracle2020}. NetBeans incluye soporte nativo para tecnologías Java EE como Servlets, JSP, JDBC, y facilita la integración con servidores de aplicaciones.

Para este proyecto se utilizó \textbf{Java Web con Ant} como sistema de construcción. Apache Ant es una herramienta de automatización de compilación basada en XML que permite definir tareas de compilación, empaquetado y despliegue de aplicaciones Java. A diferencia de Maven o Gradle, Ant ofrece mayor flexibilidad en la definición de procesos de construcción personalizados, siendo ideal para proyectos académicos donde se requiere comprender cada paso del proceso de compilación y despliegue.

\subsubsection{Servidor Apache Tomcat}

Apache Tomcat es un servidor web y contenedor de servlets de código abierto que implementa las especificaciones Java Servlet, JavaServer Pages (JSP) y otras tecnologías Java EE \cite{hall2011}. Tomcat proporciona un entorno ``puro Java'' para ejecutar aplicaciones web, procesando peticiones HTTP y gestionando el ciclo de vida de servlets y páginas JSP.

El servidor Tomcat actúa como intermediario entre las peticiones del navegador web y la aplicación Java, proporcionando servicios esenciales como:
\begin{itemize}
    \item Gestión del ciclo de vida de servlets y JSP
    \item Manejo de sesiones HTTP
    \item Procesamiento de peticiones y respuestas
    \item Pool de conexiones a bases de datos
    \item Gestión de seguridad y autenticación
\end{itemize}

Para este proyecto, Tomcat fue configurado en NetBeans para permitir el despliegue automático de la aplicación durante el desarrollo, facilitando las pruebas y depuración del sistema.

\subsection{Patrón de Arquitectura MVC}

El patrón Modelo-Vista-Controlador (MVC) es una arquitectura de software que separa la lógica de negocio, la presentación y el control de flujo en tres componentes distintos e interconectados \cite{gamma1994}. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y el trabajo en equipo, ya que diferentes desarrolladores pueden trabajar en cada capa de forma independiente.

El \textbf{Modelo} representa la lógica de negocio y los datos de la aplicación. Contiene las clases que modelan las entidades del dominio (Usuario, Producto, Pedido) y encapsula las reglas de negocio. En el sistema desarrollado, las clases del paquete modelo implementan la estructura de datos y los métodos que operan sobre ellos, independientemente de cómo se presentan o controlan.

La \textbf{Vista} es responsable de la presentación de la información al usuario. En aplicaciones web Java, las vistas se implementan mediante JSP (JavaServer Pages), que combinan HTML con código Java para generar páginas dinámicas. Las vistas acceden al modelo únicamente para lectura, nunca para modificación directa, manteniendo la separación de responsabilidades.

El \textbf{Controlador} actúa como intermediario entre el modelo y la vista, procesando las peticiones del usuario, invocando la lógica de negocio apropiada, y seleccionando la vista adecuada para mostrar los resultados. En Java EE, los Servlets funcionan como controladores, recibiendo peticiones HTTP, interactuando con el modelo, y redirigiendo a las vistas JSP correspondientes \cite{walls2015}.

\subsection{Patrón DAO (Data Access Object)}

El patrón DAO proporciona una interfaz abstracta para acceder a datos de cualquier fuente, típicamente una base de datos relacional. Este patrón encapsula toda la lógica de acceso a datos, separándola completamente de la lógica de negocio \cite{alur2003}. Los beneficios principales incluyen la centralización del acceso a datos, facilidad para cambiar de tecnología de persistencia, y simplificación de las pruebas unitarias mediante la posibilidad de crear implementaciones simuladas.

Un DAO típico define operaciones CRUD (Create, Read, Update, Delete) para una entidad específica del dominio. Por ejemplo, UsuarioDAO proporciona métodos como insertar(), buscarPorId(), listarTodos(), actualizar() y eliminar(), encapsulando todo el código SQL necesario para estas operaciones. Esta abstracción permite que el resto de la aplicación trabaje con objetos Java sin preocuparse por los detalles de la persistencia.

La implementación de DAO utiliza JDBC (Java Database Connectivity) para establecer conexiones con la base de datos, preparar consultas SQL, ejecutarlas y mapear los resultados a objetos del modelo. El manejo adecuado de conexiones, transacciones y excepciones es fundamental para garantizar la integridad y consistencia de los datos \cite{bauer2015}.

\subsection{Servlets y JSP}

Los Servlets son componentes Java del lado del servidor que extienden las capacidades de los servidores web, procesando peticiones y generando respuestas dinámicamente \cite{hall2011}. Un Servlet es una clase Java que implementa la interfaz javax.servlet.Servlet, generalmente extendiendo HttpServlet para manejar peticiones HTTP. Los métodos doGet() y doPost() procesan peticiones GET y POST respectivamente, permitiendo implementar la lógica de control de la aplicación.

Las JSP (JavaServer Pages) son una tecnología que simplifica la creación de contenido web dinámico, permitiendo mezclar HTML estático con código Java. Las páginas JSP se compilan automáticamente en Servlets la primera vez que son solicitadas, combinando la simplicidad de HTML con el poder de Java. Esta tecnología facilita la creación de interfaces de usuario dinámicas sin necesidad de generar todo el HTML mediante código Java.

La combinación de Servlets y JSP implementa naturalmente el patrón MVC: los Servlets actúan como controladores procesando la lógica de negocio, mientras que las JSP sirven como vistas presentando la información. Esta arquitectura permite desarrollo ágil, mantenimiento simplificado y separación clara de responsabilidades entre diseñadores (JSP) y programadores (Servlets).

\section{Análisis y Diseño}

Esta sección presenta el diseño conceptual del sistema mediante diagramas UML y el modelo entidad-relación de la base de datos. El enfoque se centra en el diseño orientado a objetos de las clases del modelo y su correspondiente mapeo a tablas relacionales, aplicando los principios fundamentales de POO y bases de datos relacionales para crear una arquitectura robusta y mantenible.

\subsection{Diagrama de Clases del Modelo}

El diagrama de clases del modelo representa la estructura fundamental del sistema, mostrando las entidades principales del dominio, sus atributos, métodos y las relaciones entre ellas. Este diagrama constituye el núcleo de la aplicación, ya que en estas clases se aplican directamente los conceptos de herencia, polimorfismo, encapsulamiento y abstracción estudiados en el curso.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/diagramUML.png}
\caption{Diagrama de clases del modelo del sistema}
\label{fig:diagrama-clases}
\end{figure}

El diagrama presenta las clases principales que modelan el dominio del negocio:

\begin{itemize}
    \item \textbf{Usuario (abstracta)}: Clase base que define la estructura común para todos los tipos de usuarios
    \item \textbf{Administrador, Cajero, Cliente}: Clases especializadas que heredan de Usuario
    \item \textbf{Producto}: Representa los artículos disponibles en el cafetín
    \item \textbf{Pedido}: Modela las órdenes realizadas por los clientes
    \item \textbf{DetallePedido}: Representa cada línea de un pedido con su producto y cantidad
\end{itemize}

Este diseño permite una clara separación de responsabilidades y facilita la extensibilidad del sistema, ya que agregar nuevos tipos de usuarios o entidades solo requiere crear nuevas clases que sigan la estructura establecida.

\subsection{Explicación de las Relaciones entre Clases}

Las relaciones entre clases definen cómo los objetos del sistema interactúan y se conectan entre sí. Cada tipo de relación tiene implicaciones específicas en la implementación y el comportamiento del sistema.

\subsubsection{Herencia en la jerarquía de Usuario}

La clase abstracta \texttt{Usuario} define la estructura y comportamiento común para todos los tipos de usuarios del sistema. Las clases \texttt{Administrador}, \texttt{Cajero} y \texttt{Cliente} heredan de \texttt{Usuario}, especializando su funcionalidad según el rol específico. Esta relación de herencia permite aplicar \textbf{polimorfismo}, donde un método puede trabajar con cualquier tipo de Usuario sin conocer su tipo específico, simplemente invocando los métodos abstractos que cada subclase implementa de forma particular.

La decisión de hacer \texttt{Usuario} abstracta se justifica porque no tiene sentido crear instancias de un ``Usuario'' genérico; todo usuario del sistema debe tener un rol específico (administrador, cajero o cliente). Los métodos abstractos como \texttt{mostrarInfo()}, \texttt{calcularAcceso()} y \texttt{getRol()} obligan a cada subclase a proporcionar su propia implementación, garantizando que cada tipo de usuario tenga comportamiento específico para estas operaciones.

Esta jerarquía ejemplifica el principio de \textbf{abstracción}, donde se identifican las características esenciales comunes (nombre, email, password, fechaRegistro) y se definen en la clase base, mientras que las características específicas de cada rol se implementan en las subclases correspondientes.

\subsubsection{Asociación entre Cliente y Pedido}

Un \texttt{Cliente} puede realizar múltiples \texttt{Pedidos} a lo largo del tiempo, estableciendo una relación \textbf{uno-a-muchos} (1..*). Esta asociación se implementa mediante el atributo \texttt{idUsuario} en la clase \texttt{Pedido}, que funciona como clave foránea referenciando al cliente que realizó el pedido.

La relación es \textbf{unidireccional} desde \texttt{Pedido} hacia \texttt{Cliente}, ya que los pedidos necesitan saber quién los realizó para propósitos de registro y seguimiento, pero un cliente no mantiene una lista de todos sus pedidos en memoria (esta información se consulta desde la base de datos cuando es necesario). Esta decisión de diseño optimiza el uso de memoria y evita inconsistencias entre objetos en memoria y datos persistidos.

\subsubsection{Composición entre Pedido y DetallePedido}

Un \texttt{Pedido} se compone de múltiples \texttt{DetallePedido}, donde cada detalle representa un producto específico con su cantidad y precio unitario. Esta es una relación de \textbf{composición fuerte}, representada en UML con un rombo relleno, porque:

\begin{enumerate}
    \item Los detalles no pueden existir sin un pedido padre
    \item Si se elimina un pedido, todos sus detalles también deben eliminarse
    \item El ciclo de vida de los detalles está completamente controlado por el pedido
\end{enumerate}

La clase \texttt{Pedido} mantiene una lista (\texttt{List<DetallePedido>}) de todos sus detalles, permitiendo gestionar todos los productos del pedido como una unidad cohesiva. Esta relación también facilita el cálculo automático del total del pedido sumando los subtotales de cada detalle.

\subsubsection{Asociación entre DetallePedido y Producto}

Cada \texttt{DetallePedido} referencia al \texttt{Producto} que se está ordenando mediante el atributo \texttt{idProducto}. Esta es una \textbf{asociación simple} (no composición ni agregación), ya que:

\begin{itemize}
    \item El detalle necesita conocer el producto para obtener su información (nombre, precio)
    \item El detalle no posee ni controla el ciclo de vida del producto
    \item Los productos existen independientemente de los pedidos que los referencian
\end{itemize}

Una característica importante de esta relación es que cuando se crea un detalle de pedido, se captura y almacena el \texttt{precioUnitario} del producto en ese momento específico. Esto garantiza que cambios futuros en el precio del producto no afecten pedidos históricos, manteniendo la integridad de los registros comerciales.

\subsection{Modelo de Base de Datos}

El modelo de base de datos representa el esquema relacional que persiste la información del sistema. Este diseño implementa las entidades del modelo orientado a objetos mediante tablas relacionales, aplicando principios de normalización para garantizar la integridad y eficiencia de los datos.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{img/diagramaBD.png}
\caption{Diagrama entidad-relación de la base de datos}
\label{fig:diagrama-bd}
\end{figure}

\subsubsection{Descripción de las Tablas Principales}

\paragraph{Tabla USUARIOS}
Almacena la información de todos los usuarios del sistema, implementando una estrategia de \textbf{tabla única para jerarquía de herencia} (Single Table Inheritance). Esta tabla contiene:

\begin{itemize}
    \item Atributos comunes: \texttt{id\_usuario}, \texttt{nombre}, \texttt{apellido}, \texttt{email}, \texttt{password}, \texttt{rol}, \texttt{fecha\_registro}, \texttt{activo}
    \item Atributos específicos de Administrador: \texttt{area\_gestion}, \texttt{nivel\_acceso}
    \item Atributos específicos de Cliente: \texttt{puntos\_acumulados}, \texttt{tipo\_membresia}, \texttt{saldo}
    \item Atributos específicos de Cajero: \texttt{turno}, \texttt{ventas\_diarias}
\end{itemize}

El campo \texttt{rol} actúa como discriminador para identificar el tipo específico de usuario. Los atributos no aplicables a un rol se mantienen como NULL. Esta estrategia simplifica las consultas y evita múltiples JOINs, aunque sacrifica algo de normalización.

\paragraph{Tabla PRODUCTOS}
Contiene el catálogo de productos disponibles en el cafetín. Incluye información descriptiva (\texttt{nombre}, \texttt{descripcion}), comercial (\texttt{precio}, \texttt{categoria}), y de disponibilidad (\texttt{stock}, \texttt{disponible}). Los campos \texttt{fecha\_creacion} y \texttt{fecha\_actualizacion} permiten auditoría de cambios.

\paragraph{Tabla PEDIDOS}
Registra las órdenes realizadas por los clientes. Cada pedido está vinculado a un usuario mediante \texttt{id\_usuario} (clave foránea), contiene información temporal (\texttt{fecha\_pedido}), financiera (\texttt{total}, \texttt{metodo\_pago}), y de seguimiento (\texttt{estado}, \texttt{observaciones}).

\paragraph{Tabla DETALLE\_PEDIDOS}
Implementa la relación muchos-a-muchos entre PEDIDOS y PRODUCTOS, almacenando los productos específicos de cada pedido. Cada registro contiene \texttt{cantidad}, \texttt{precio\_unitario} (capturado en el momento de la orden), y \texttt{subtotal} calculado. Esta tabla es esencial para mantener el histórico exacto de las transacciones.

\paragraph{Tabla INVENTARIO}
Gestiona los niveles de stock de cada producto, estableciendo umbrales mínimos y máximos (\texttt{cantidad\_minima}, \texttt{cantidad\_maxima}) para alertas de reabastecimiento. La relación uno-a-uno con PRODUCTOS se implementa mediante una clave foránea única (\texttt{id\_producto}).

\paragraph{Tabla MOVIMIENTOS\_INVENTARIO}
Registra todos los cambios en el inventario para auditoría y trazabilidad. Cada movimiento especifica el \texttt{tipo\_movimiento} (entrada, salida, ajuste), la \texttt{cantidad} afectada, el \texttt{motivo}, y opcionalmente el usuario responsable. Esta tabla es crucial para el control de inventario y detección de discrepancias.

\paragraph{Tabla REPORTES}
Almacena reportes generados por los administradores, incluyendo el \texttt{tipo\_reporte}, \texttt{fecha\_generacion}, y el \texttt{contenido} serializado. Esta tabla permite mantener un historial de análisis y facilita la generación de reportes recurrentes.

\subsubsection{Relaciones e Integridad Referencial}

El esquema implementa las siguientes relaciones mediante claves foráneas:

\begin{itemize}
    \item \textbf{USUARIOS $\rightarrow$ PEDIDOS}: Un usuario puede realizar múltiples pedidos (1:N)
    \item \textbf{PEDIDOS $\rightarrow$ DETALLE\_PEDIDOS}: Un pedido contiene múltiples detalles (1:N) con \texttt{ON DELETE CASCADE}
    \item \textbf{PRODUCTOS $\rightarrow$ DETALLE\_PEDIDOS}: Un producto puede aparecer en múltiples detalles (1:N)
    \item \textbf{PRODUCTOS $\rightarrow$ INVENTARIO}: Relación uno-a-uno estricta mediante clave foránea única
    \item \textbf{PRODUCTOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Trazabilidad de cambios (1:N)
    \item \textbf{USUARIOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Auditoría de responsables (1:N, nullable)
    \item \textbf{USUARIOS $\rightarrow$ REPORTES}: Trazabilidad de generación (1:N, nullable)
\end{itemize}

Las restricciones \texttt{ON DELETE CASCADE} en DETALLE\_PEDIDOS garantizan que al eliminar un pedido, sus detalles se eliminen automáticamente, manteniendo la coherencia de los datos y reflejando la relación de composición del modelo orientado a objetos.

\subsubsection{Normalización y Optimización}

El esquema de base de datos se encuentra en \textbf{Tercera Forma Normal (3FN)}:

\begin{itemize}
    \item \textbf{1FN}: Todos los atributos contienen valores atómicos, sin grupos repetitivos
    \item \textbf{2FN}: No existen dependencias parciales; todos los atributos no clave dependen completamente de la clave primaria
    \item \textbf{3FN}: No existen dependencias transitivas; los atributos no clave no dependen de otros atributos no clave
\end{itemize}

Se han definido índices sobre las columnas más consultadas (\texttt{email} en USUARIOS, \texttt{id\_producto} en INVENTARIO) para optimizar el rendimiento de las búsquedas frecuentes.

\subsection{Arquitectura del Sistema: Patrón MVC}

El sistema implementa el patrón de arquitectura Modelo-Vista-Controlador (MVC), que organiza la aplicación en cuatro capas independientes e interconectadas. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y permite que diferentes componentes evolucionen de forma independiente sin afectar al resto del sistema.

\subsubsection{Capa de Presentación (Vista)}

La capa de presentación está compuesta por páginas JSP (JavaServer Pages) que generan la interfaz de usuario del sistema. Como se muestra en la Figura~\ref{fig:capa-vista}, esta capa se divide en tres módulos principales según el tipo de funcionalidad.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-vista.png}
\caption{Capa de Presentación - Páginas JSP del sistema}
\label{fig:capa-vista}
\end{figure}

El \textbf{Módulo de Autenticación} incluye las páginas \texttt{login.jsp}, \texttt{registro.jsp} e \texttt{index.jsp}, que gestionan el acceso al sistema y el registro de nuevos usuarios. Estas páginas implementan formularios HTML con validación tanto del lado del cliente (JavaScript) como del servidor (Servlets).

El \textbf{Módulo del Cliente} contiene las vistas específicas para usuarios con rol de cliente. La página \texttt{menu.jsp} presenta el catálogo completo de productos disponibles con sus imágenes, precios y descripciones. \texttt{carrito.jsp} permite al cliente revisar y modificar los productos seleccionados antes de confirmar la compra. \texttt{mis-pedidos.jsp} muestra el historial de pedidos realizados con sus estados actuales. \texttt{perfil.jsp} permite al usuario consultar y actualizar su información personal, incluyendo puntos acumulados y tipo de membresía. Finalmente, \texttt{confirmacion.jsp} proporciona retroalimentación visual del éxito de la transacción.

El \textbf{Módulo Administrativo} agrupa las interfaces para administradores y cajeros. \texttt{dashboard.jsp} presenta un panel de control con estadísticas y métricas del negocio. \texttt{productos.jsp} permite gestionar el catálogo completo mediante operaciones CRUD. \texttt{pedidos.jsp} facilita el procesamiento y seguimiento de órdenes. \texttt{usuarios.jsp} administra las cuentas del sistema. \texttt{reportes.jsp} genera informes analíticos sobre ventas, productos más vendidos y tendencias. Las páginas auxiliares \texttt{producto-form.jsp} y \texttt{pedido-detalle.jsp} proporcionan formularios específicos para operaciones de creación y edición.

Las páginas JSP utilizan hojas de estilo CSS (\texttt{style.css}) almacenadas en la carpeta \texttt{css/} y recursos gráficos en \texttt{images/} para proporcionar una interfaz visual coherente. Esta capa solo se encarga de la presentación de datos y captura de entrada del usuario, delegando toda la lógica de negocio al controlador mediante peticiones HTTP.

\subsubsection{Capa de Control (Controlador)}

Los Servlets actúan como controladores que procesan las peticiones HTTP del usuario, ejecutan la lógica de negocio apropiada, e invocan los métodos del modelo para realizar operaciones sobre los datos. La Figura~\ref{fig:capa-control} muestra los cuatro servlets principales del sistema.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-control.png}
\caption{Capa de Control - Servlets del sistema}
\label{fig:capa-control}
\end{figure}

\textbf{ServletLogin} gestiona todo lo relacionado con autenticación y sesiones. El método \texttt{login()} recibe las credenciales del usuario, invoca \texttt{UsuarioDAO.autenticar()} para validarlas contra la base de datos, y establece variables de sesión con la información del usuario autenticado (id, nombre, rol, permisos específicos). El método \texttt{registro()} procesa la creación de nuevas cuentas de cliente, validando que las contraseñas coincidan y que el email no esté previamente registrado. \texttt{logout()} invalida la sesión actual y redirige al usuario a la página de inicio.

\textbf{ServletPedidos} administra el ciclo completo de los pedidos. \texttt{listar()} obtiene todos los pedidos del sistema o filtra por usuario según el rol. \texttt{crear()} procesa la generación de un nuevo pedido a partir del carrito de compras, validando stock disponible, calculando descuentos por membresía, actualizando inventarios y generando los registros correspondientes en las tablas \texttt{pedidos} y \texttt{detalle\_pedido}. \texttt{actualizar()} permite cambiar el estado de un pedido (pendiente → preparando → listo → entregado). \texttt{cancelar()} marca un pedido como cancelado y restaura el stock de los productos involucrados.

\textbf{ServletProductos} implementa las operaciones CRUD sobre el catálogo. \texttt{listar()} recupera todos los productos o filtra por categoría. \texttt{insertar()} valida y crea nuevos productos en el sistema. \texttt{actualizar()} modifica información existente como precio, descripción o stock. \texttt{eliminar()} realiza eliminación lógica (marcando como no disponible) o física según sea apropiado.

\textbf{ServletUsuarios} proporciona funcionalidades administrativas para gestionar cuentas. Similar a ServletProductos, implementa operaciones CRUD completas, permitiendo crear usuarios con roles específicos (mediante instanceof para determinar qué campos adicionales configurar), modificar información de usuarios existentes, y desactivar cuentas cuando sea necesario sin eliminarlas físicamente.

Todos los servlets siguen un patrón consistente: el método \texttt{doPost()} recibe los parámetros de la petición HTTP, determina la acción a ejecutar mediante un parámetro ``accion'', valida los datos de entrada, invoca métodos del modelo a través de los DAOs, y redirige (\texttt{response.sendRedirect()}) o reenvía (\texttt{request.getRequestDispatcher().forward()}) a la vista apropiada con los resultados. El método \texttt{doGet()} típicamente delega a \texttt{doPost()} para simplificar el manejo de peticiones.

\subsubsection{Capa de Modelo}

La capa de modelo encapsula toda la lógica de negocio y se subdivide en dos componentes principales: las clases del dominio y la capa de acceso a datos. La Figura~\ref{fig:capa-modelo} ilustra esta organización.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-modelo.png}
\caption{Capa de Modelo - Clases del dominio y capa DAO}
\label{fig:capa-modelo}
\end{figure}

Las \textbf{Clases del Dominio} representan las entidades del negocio con sus atributos y comportamientos. La jerarquía de \texttt{Usuario} implementa herencia y polimorfismo: la clase abstracta base define métodos abstractos como \texttt{mostrarInfo()}, \texttt{calcularAcceso()} y \texttt{getRol()} que cada subclase (\texttt{Administrador}, \texttt{Cajero}, \texttt{Cliente}) implementa según su rol específico. La clase \texttt{Cliente} encapsula lógica relacionada con membresías: \texttt{acumularPuntos()} agrega puntos según el total de compra, \texttt{actualizarMembresia()} recalcula el tipo de membresía según puntos acumulados, y \texttt{calcularDescuento()} retorna el porcentaje de descuento correspondiente.

La clase \texttt{Producto} modela los artículos del cafetín con métodos como \texttt{hayStock()} que verifica disponibilidad, \texttt{actualizarStock()} que modifica cantidades y ajusta el estado de disponibilidad, y \texttt{obtenerEstado()} que genera mensajes descriptivos según el nivel de stock.

\texttt{Pedido} representa una orden completa y mantiene una lista de \texttt{DetallePedido}. El método \texttt{agregarDetalle()} añade productos al pedido e invoca automáticamente \texttt{calcularTotal()} para mantener actualizado el total. \texttt{cambiarEstado()} valida que las transiciones de estado sean legales antes de aplicarlas.

La \textbf{Capa DAO (Data Access Object)} abstrae completamente el acceso a la base de datos. \texttt{ConexionBD} gestiona las conexiones a MySQL mediante JDBC, implementando el patrón Singleton en el método estático \texttt{getConexion()} para reutilizar conexiones y optimizar recursos. Esta clase carga el driver JDBC (\texttt{com.mysql.cj.jdbc.Driver}) y establece la conexión con los parámetros configurados (URL, usuario, contraseña).

Los DAOs específicos encapsulan todo el código SQL necesario. \texttt{UsuarioDAO.autenticar()} ejecuta una consulta parametrizada que valida email y contraseña (encriptada con MD5), y mapea el resultado a la clase correspondiente (\texttt{Administrador}, \texttt{Cajero} o \texttt{Cliente}) según el campo \texttt{rol}. \texttt{UsuarioDAO.insertar()} utiliza \texttt{instanceof} para determinar qué campos específicos del rol deben poblarse en la inserción.

\texttt{ProductoDAO} implementa operaciones CRUD completas: \texttt{listarTodos()} retorna una lista de objetos \texttt{Producto} mapeados desde un \texttt{ResultSet}, \texttt{buscarPorId()} localiza un producto específico, y los métodos de modificación ejecutan sentencias SQL UPDATE, INSERT o DELETE según corresponda.

\texttt{PedidoDAO} maneja la persistencia de pedidos, que requiere coordinar múltiples tablas. El método \texttt{insertar()} primero crea el registro en la tabla \texttt{pedidos}, recupera el ID generado automáticamente, y luego inserta cada detalle en \texttt{detalle\_pedido} asociándolo con el pedido padre.

Esta separación entre modelo de dominio y acceso a datos permite cambiar la tecnología de persistencia sin afectar la lógica de negocio. Por ejemplo, migrar de MySQL a PostgreSQL solo requeriría reimplementar las clases DAO y modificar \texttt{ConexionBD}, sin tocar las clases del dominio ni los Servlets.

\subsubsection{Capa de Persistencia}

La capa de persistencia almacena toda la información del sistema en una base de datos MySQL. La Figura~\ref{fig:capa-persistencia} muestra las cuatro tablas principales y sus relaciones.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-persistencia.png}
\caption{Capa de Persistencia - Tablas de la base de datos MySQL}
\label{fig:capa-persistencia}
\end{figure}

La tabla \texttt{usuarios} almacena la información de todos los usuarios del sistema. El campo \texttt{id\_usuario} es la clave primaria autoincremental. Los campos \texttt{nombre}, \texttt{apellido}, \texttt{email} y \texttt{password} (encriptado con MD5) son comunes a todos los usuarios. El campo \texttt{rol} (ENUM: 'administrador', 'cajero', 'cliente') determina el tipo de usuario. Campos adicionales como \texttt{area\_gestion}, \texttt{nivel\_acceso}, \texttt{puntos\_acumulados}, \texttt{tipo\_membresia}, \texttt{turno} y \texttt{saldo} se utilizan según el rol específico, quedando NULL cuando no aplican. \texttt{activo} permite desactivación lógica y \texttt{fecha\_registro} registra la creación de la cuenta.

La tabla \texttt{productos} contiene el catálogo del cafetín con \texttt{id\_producto} como clave primaria. Los campos \texttt{nombre}, \texttt{descripcion}, \texttt{precio}, \texttt{stock}, \texttt{categoria} e \texttt{imagen} describen cada artículo. El campo booleano \texttt{disponible} controla si el producto se muestra en el menú.

La tabla \texttt{pedidos} registra cada orden realizada. \texttt{id\_pedido} es la clave primaria, mientras que \texttt{id\_usuario} es una clave foránea que referencia al cliente que realizó el pedido, estableciendo una relación uno-a-muchos (un cliente puede tener múltiples pedidos). \texttt{fecha\_pedido} registra el timestamp de creación, \texttt{total} almacena el monto final, \texttt{estado} (ENUM: 'pendiente', 'preparando', 'listo', 'entregado', 'cancelado') indica el estado actual, \texttt{metodo\_pago} especifica cómo se pagó, y \texttt{observaciones} permite notas adicionales.

La tabla \texttt{detalle\_pedido} implementa la relación muchos-a-muchos entre pedidos y productos. Cada registro representa una línea del pedido con \texttt{id\_detalle} como clave primaria. \texttt{id\_pedido} referencia al pedido padre (relación de composición: si se elimina el pedido, se eliminan sus detalles). \texttt{id\_producto} referencia al producto ordenado. \texttt{cantidad} especifica cuántas unidades se ordenaron. \texttt{precio\_unitario} captura el precio del producto en el momento de la compra (crucial para mantener integridad histórica), y \texttt{subtotal} almacena el resultado de cantidad × precio\_unitario.

Las claves foráneas implementadas con \texttt{FOREIGN KEY ... REFERENCES} garantizan integridad referencial: no se puede crear un pedido para un usuario inexistente, ni un detalle para un pedido o producto inexistente. Las opciones \texttt{ON DELETE CASCADE} en la relación pedido-detalle aseguran que al eliminar un pedido se eliminen automáticamente todos sus detalles.

El motor MySQL proporciona soporte para transacciones ACID, índices para optimizar consultas frecuentes, y tipos de datos específicos como DECIMAL para precios (evitando problemas de precisión con punto flotante) y ENUM para campos con valores limitados.

\subsubsection{Flujo de Comunicación}

El flujo típico de una operación en el sistema sigue estos pasos secuenciales:

\begin{enumerate}
    \item El usuario interactúa con una \textbf{Vista (JSP)}, por ejemplo, completando el formulario de login y haciendo clic en ``Iniciar Sesión''
    
    \item La vista genera una petición HTTP POST al \textbf{Controlador (Servlet)} apropiado, en este caso \texttt{ServletLogin}, incluyendo los parámetros \texttt{email}, \texttt{password} y \texttt{accion=login}
    
    \item El controlador recibe la petición mediante \texttt{doPost()}, extrae los parámetros con \texttt{request.getParameter()}, y determina qué acción ejecutar
    
    \item El controlador invoca métodos del \textbf{Modelo}. En el ejemplo, llama a \texttt{usuarioDAO.autenticar(email, password)}
    
    \item El DAO ejecuta una consulta SQL parametrizada contra la \textbf{Base de Datos} mediante JDBC: \texttt{SELECT * FROM usuarios WHERE email = ? AND password = MD5(?) AND activo = true}
    
    \item MySQL procesa la consulta y retorna un \texttt{ResultSet} con los datos del usuario si las credenciales son válidas
    
    \item El DAO mapea el \texttt{ResultSet} a un objeto del modelo (\texttt{Usuario}, \texttt{Administrador}, \texttt{Cajero} o \texttt{Cliente}) según el campo \texttt{rol}, configurando todos sus atributos
    
    \item El objeto creado retorna al controlador a través de la pila de llamadas
    
    \item El controlador procesa el resultado: si el usuario es válido, crea/actualiza la sesión HTTP con \texttt{request.getSession()} y almacena información relevante como atributos de sesión
    
    \item Finalmente, el controlador selecciona la vista apropiada según el rol del usuario (dashboard para administradores/cajeros, menú para clientes) y redirige mediante \texttt{response.sendRedirect()}, o incluye mensajes de error y reenvía a la misma página con \texttt{request.getRequestDispatcher().forward()}
\end{enumerate}

Este patrón se repite para todas las operaciones del sistema: crear pedido, actualizar producto, generar reporte, etc. La arquitectura en capas proporciona múltiples beneficios: \textbf{separación clara de responsabilidades} (cada componente tiene un propósito único), \textbf{facilidad de prueba unitaria} (cada capa puede probarse independientemente), \textbf{desarrollo paralelo} (diferentes equipos pueden trabajar en diferentes capas simultáneamente), y \textbf{flexibilidad} para cambios (modificar la interfaz no afecta la lógica de negocio, cambiar de base de datos solo requiere reimplementar DAOs).

\section{Implementación}

\subsection{Clases del Modelo}

\subsubsection{Usuario.java}

\begin{javacode}{Usuario.java}
package com.cafeteria.modelo;
import java.sql.Timestamp;
public abstract class Usuario {
    protected int idUsuario;
    protected String nombre;
    protected String apellido;
    protected String email;
    protected String password;
    protected Timestamp fechaRegistro;
    protected boolean activo;
    public Usuario(String nombre, String apellido, String email, String password) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.email = email;
        this.password = password;
        this.activo = true;
    }
    public Usuario() { }
    public int getIdUsuario() { return idUsuario; }
    public void setIdUsuario(int idUsuario) { this.idUsuario = idUsuario; }
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
    public String getApellido() { return apellido; }
    public void setApellido(String apellido) { this.apellido = apellido; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    public Timestamp getFechaRegistro() { return fechaRegistro; }
    public void setFechaRegistro(Timestamp fechaRegistro) { this.fechaRegistro = fechaRegistro; }
    public boolean isActivo() { return activo; }
    public void setActivo(boolean activo) { this.activo = activo; }
    public String getNombreCompleto() { return nombre + " " + apellido; }
    public boolean validarCredenciales(String email, String password) {
        return this.email.equals(email) && this.password.equals(password) && this.activo;
    }
    public abstract String mostrarInfo();
    public abstract String calcularAcceso();
    public abstract String getRol();
    @Override
    public String toString() {
        return "Usuario{" + 
               "id=" + idUsuario + 
               ", nombre=" + getNombreCompleto() + 
               ", email=" + email + 
               ", rol=" + getRol() + 
               '}';
    }
}
\end{javacode}

\subsubsection{Administrador.java}

\begin{javacode}{Administrador.java}
package com.cafeteria.modelo;
public class Administrador extends Usuario {
    private String areaGestion;
    private int nivelAcceso;
    public Administrador(String nombre, String apellido, String email, String password, String areaGestion) {
        super(nombre, apellido, email, password);
        this.areaGestion = areaGestion;
        this.nivelAcceso = 3;
    }
    public Administrador() { super(); }
    public String getAreaGestion() { return areaGestion; }
    public void setAreaGestion(String areaGestion) { this.areaGestion = areaGestion; }
    public int getNivelAcceso() { return nivelAcceso; }
    public void setNivelAcceso(int nivelAcceso) { this.nivelAcceso = nivelAcceso; }
    @Override
    public String mostrarInfo() {
        return String.format("ADMINISTRADOR\nNombre: %s\nEmail: %s\nArea: %s\nNivel de Acceso: %d\nEstado: %s",
                           getNombreCompleto(), email, areaGestion, nivelAcceso, activo ? "Activo" : "Inactivo");
    }
    @Override
    public String calcularAcceso() {
        return "Acceso TOTAL: Dashboard, Productos, Pedidos, Usuarios, Reportes, Inventario";
    }
    @Override
    public String getRol() { return "administrador"; }
    public String gestionarSistema() {
        return "Gestión completa del sistema habilitada para: " + getNombreCompleto();
    }
    public String generarReportes() {
        return "Generando reportes administrativos...";
    }
}
\end{javacode}

\subsubsection{Cliente.java}

\begin{javacode}{Cliente.java}
package com.cafeteria.modelo;
public class Cliente extends Usuario {
    private int puntosAcumulados;
    private String tipoMembresia;
    private double saldo;
    public Cliente(String nombre, String apellido, String email, String password) {
        super(nombre, apellido, email, password);
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }
    public Cliente() {
        super();
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }
    public int getPuntosAcumulados() { return puntosAcumulados; }
    public void setPuntosAcumulados(int puntosAcumulados) {
        this.puntosAcumulados = puntosAcumulados;
        actualizarMembresia();
    }
    public String getTipoMembresia() { return tipoMembresia; }
    public void setTipoMembresia(String tipoMembresia) { this.tipoMembresia = tipoMembresia; }
    public double getSaldo() { return saldo; }
    public void setSaldo(double saldo) { this.saldo = saldo; }
    @Override
    public String mostrarInfo() {
        return String.format("CLIENTE\nNombre: %s\nEmail: %s\nMembresía: %s\nPuntos: %d\nSaldo: S/ %.2f\nEstado: %s",
                           getNombreCompleto(), email, tipoMembresia, puntosAcumulados, saldo, activo ? "Activo" : "Inactivo");
    }
    @Override
    public String calcularAcceso() {
        return "Acceso CLIENTE: Menú, Carrito, Mis Pedidos, Mi Perfil";
    }
    @Override
    public String getRol() { return "cliente"; }
    public boolean agregarSaldo(double monto) {
        if (monto <= 0) return false;
        this.saldo += monto;
        return true;
    }
    public boolean tieneSaldoSuficiente(double monto) { return this.saldo >= monto; }
    public boolean realizarCompra(double totalCompra) {
        if (!tieneSaldoSuficiente(totalCompra)) return false;
        this.saldo -= totalCompra;
        acumularPuntos(totalCompra);
        return true;
    }
    public void acumularPuntos(double totalCompra) {
        int puntosGanados = (int) (totalCompra / 5);
        this.puntosAcumulados += puntosGanados;
        actualizarMembresia();
    }
    private void actualizarMembresia() {
        if (puntosAcumulados >= 100) this.tipoMembresia = "Oro";
        else if (puntosAcumulados >= 50) this.tipoMembresia = "Plata";
        else if (puntosAcumulados >= 20) this.tipoMembresia = "Bronce";
        else this.tipoMembresia = "Ninguna";
    }
    public double calcularDescuento() {
        switch (tipoMembresia) {
            case "Oro": return 0.15;
            case "Plata": return 0.10;
            case "Bronce": return 0.05;
            case "Ninguna": return 0.0;
            default: return 0.0;
        }
    }
}
\end{javacode}

\subsubsection{Producto.java}

\begin{javacode}{Producto.java}
package com.cafeteria.modelo;
public class Producto {
    private int idProducto;
    private String nombre;
    private String descripcion;
    private double precio;
    private int stock;
    private String categoria;
    private boolean disponible;
    private String imagen;
    public Producto() {}
    public Producto(String nombre, String descripcion, double precio, int stock, String categoria) {
        this.nombre = nombre;
        this.descripcion = descripcion;
        this.precio = precio;
        this.stock = stock;
        this.categoria = categoria;
        this.disponible = true;
    }
    public int getIdProducto() { return idProducto; }
    public void setIdProducto(int idProducto) { this.idProducto = idProducto; }
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
    public String getDescripcion() { return descripcion; }
    public void setDescripcion(String descripcion) { this.descripcion = descripcion; }
    public double getPrecio() { return precio; }
    public void setPrecio(double precio) { this.precio = precio; }
    public int getStock() { return stock; }
    public void setStock(int stock) { this.stock = stock; }
    public String getCategoria() { return categoria; }
    public void setCategoria(String categoria) { this.categoria = categoria; }
    public boolean isDisponible() { return disponible; }
    public void setDisponible(boolean disponible) { this.disponible = disponible; }
    public String getImagen() { return imagen; }
    public void setImagen(String imagen) { this.imagen = imagen; }
    public boolean hayStock() { return stock > 0 && disponible; }
    public void actualizarStock(int cantidad) {
        this.stock += cantidad;
        if (this.stock <= 0) this.disponible = false;
        else this.disponible = true;
    }
    public String obtenerEstado() {
        if (!disponible) return "No disponible";
        if (stock <= 5) return "Stock bajo";
        if (stock <= 10) return "Stock medio";
        return "Disponible";
    }
    @Override
    public String toString() {
        return String.format("Producto{id=%d, nombre='%s', precio=S/%.2f, stock=%d, estado='%s'}", 
                           idProducto, nombre, precio, stock, obtenerEstado());
    }
}
\end{javacode}

\subsubsection{Pedido.java}

\begin{javacode}{Pedido.java}
package com.cafeteria.modelo;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
public class Pedido {
    private int idPedido;
    private int idUsuario;
    private Timestamp fechaPedido;
    private double total;
    private String estado;
    private String metodoPago;
    private String observaciones;
    private List<DetallePedido> detalles;
    public Pedido() {
        this.detalles = new ArrayList<>();
        this.estado = "pendiente";
        this.total = 0.0;
    }
    public Pedido(int idUsuario, String metodoPago) {
        this.idUsuario = idUsuario;
        this.metodoPago = metodoPago;
        this.estado = "pendiente";
        this.total = 0.0;
        this.detalles = new ArrayList<>();
    }
    public int getIdPedido() { return idPedido; }
    public void setIdPedido(int idPedido) { this.idPedido = idPedido; }
    public int getIdUsuario() { return idUsuario; }
    public void setIdUsuario(int idUsuario) { this.idUsuario = idUsuario; }
    public Timestamp getFechaPedido() { return fechaPedido; }
    public void setFechaPedido(Timestamp fechaPedido) { this.fechaPedido = fechaPedido; }
    public double getTotal() { return total; }
    public void setTotal(double total) { this.total = total; }
    public String getEstado() { return estado; }
    public void setEstado(String estado) { this.estado = estado; }
    public String getMetodoPago() { return metodoPago; }
    public void setMetodoPago(String metodoPago) { this.metodoPago = metodoPago; }
    public String getObservaciones() { return observaciones; }
    public void setObservaciones(String observaciones) { this.observaciones = observaciones; }
    public List<DetallePedido> getDetalles() { return detalles; }
    public void setDetalles(List<DetallePedido> detalles) { this.detalles = detalles; }
    public void agregarDetalle(DetallePedido detalle) {
        this.detalles.add(detalle);
        calcularTotal();
    }
    public void calcularTotal() {
        this.total = 0;
        for (DetallePedido detalle : detalles) {
            this.total += detalle.getSubtotal();
        }
    }
    public void cambiarEstado(String nuevoEstado) {
        String[] estadosValidos = {"pendiente", "preparando", "listo", "entregado", "cancelado"};
        for (String estadoValido : estadosValidos) {
            if (estadoValido.equals(nuevoEstado)) {
                this.estado = nuevoEstado;
                return;
            }
        }
        throw new IllegalArgumentException("Estado no válido: " + nuevoEstado);
    }
}
\end{javacode}

\subsubsection{DetallePedido.java}

\begin{javacode}{DetallePedido.java}
package com.cafeteria.modelo;
public class DetallePedido {
    private int idDetalle;
    private int idPedido;
    private int idProducto;
    private String nombreProducto;
    private int cantidad;
    private double precioUnitario;
    private double subtotal;
    public DetallePedido() {}
    public DetallePedido(int idProducto, int cantidad, double precioUnitario) {
        this.idProducto = idProducto;
        this.cantidad = cantidad;
        this.precioUnitario = precioUnitario;
        calcularSubtotal();
    }
    public void setIdDetalle(int idDetalle) { this.idDetalle = idDetalle; }
    public int getIdPedido() { return idPedido; }
    public void setIdPedido(int idPedido) { this.idPedido = idPedido; }
    public int getIdProducto() { return idProducto; }
    public void setIdProducto(int idProducto) { this.idProducto = idProducto; }
    public String getNombreProducto() { return nombreProducto; }
    public void setNombreProducto(String nombreProducto) { this.nombreProducto = nombreProducto; }
    public int getCantidad() { return cantidad; }
    public void setCantidad(int cantidad) { 
        this.cantidad = cantidad;
        calcularSubtotal();
    }
    public double getPrecioUnitario() { return precioUnitario; }
    public void setPrecioUnitario(double precioUnitario) { 
        this.precioUnitario = precioUnitario;
        calcularSubtotal();
    }
    public double getSubtotal() { return subtotal; }
    public void setSubtotal(double subtotal) { this.subtotal = subtotal; }
    public void calcularSubtotal() { this.subtotal = this.cantidad * this.precioUnitario; }
}
\end{javacode}

\subsection{Clases DAO (Data Access Object)}

\subsubsection{ConexionBD.java}

\begin{javacode}{ConexionBD.java}
package com.cafeteria.dao;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
public class ConexionBD {
    private static final String URL = "jdbc:mysql://localhost:3306/cafetin";
    private static final String USUARIO = "root";
    private static final String PASSWORD = "";
    private static final String DRIVER = "com.mysql.cj.jdbc.Driver";
    private static Connection conexion = null;
    private ConexionBD() { }
    public static Connection getConexion() {
        try {
            if (conexion == null || conexion.isClosed()) {
                Class.forName(DRIVER);
                conexion = DriverManager.getConnection(URL, USUARIO, PASSWORD);
                System.out.println("Conexión exitosa a la base de datos");
            }
        } catch (ClassNotFoundException e) {
            System.err.println("Error: Driver no encontrado"); e.printStackTrace();
        } catch (SQLException e) {
            System.err.println("Error al conectar con la base de datos"); e.printStackTrace();
        }
        return conexion;
    }
    public static void cerrarConexion() {
        try {
            if (conexion != null && !conexion.isClosed()) {
                conexion.close();
                System.out.println("Conexión cerrada correctamente");
            }
        } catch (SQLException e) {
            System.err.println("Error al cerrar la conexión"); e.printStackTrace();
        }
    }
    public static boolean probarConexion() {
        Connection conn = getConexion();
        return conn != null;
    }
}
\end{javacode}

\subsubsection{UsuarioDAO.java}

\begin{javacode}{UsuarioDAO.java}
package com.cafeteria.dao;
import com.cafeteria.modelo.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
public class UsuarioDAO {
    public Usuario autenticar(String email, String password) {
        Usuario usuario = null;
        String sql = "SELECT * FROM usuarios WHERE email = ? AND password = MD5(?) AND activo = true";
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, email);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                String rol = rs.getString("rol");
                switch (rol) {
                    case "administrador":
                        Administrador admin = new Administrador();
                        admin.setIdUsuario(rs.getInt("id_usuario"));
                        admin.setNombre(rs.getString("nombre"));
                        admin.setApellido(rs.getString("apellido"));
                        admin.setEmail(rs.getString("email"));
                        admin.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        admin.setActivo(rs.getBoolean("activo"));
                        admin.setAreaGestion(rs.getString("area_gestion"));
                        admin.setNivelAcceso(rs.getInt("nivel_acceso"));
                        usuario = admin;
                        break;
                    case "cliente":
                        Cliente cliente = new Cliente();
                        cliente.setIdUsuario(rs.getInt("id_usuario"));
                        cliente.setNombre(rs.getString("nombre"));
                        cliente.setApellido(rs.getString("apellido"));
                        cliente.setEmail(rs.getString("email"));
                        cliente.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        cliente.setActivo(rs.getBoolean("activo"));
                        cliente.setPuntosAcumulados(rs.getInt("puntos_acumulados"));
                        cliente.setTipoMembresia(rs.getString("tipo_membresia"));
                        cliente.setSaldo(rs.getDouble("saldo"));
                        usuario = cliente;
                        break;
                }
            }
        } catch (SQLException e) {
            System.err.println("Error al autenticar usuario: " + e.getMessage());
        }
        return usuario;
    }
    public boolean insertar(Usuario usuario) {
        String sql = "INSERT INTO usuarios (nombre, apellido, email, password, rol, " +
                    "area_gestion, nivel_acceso, puntos_acumulados, tipo_membresia, turno, saldo) " +
                    "VALUES (?, ?, ?, MD5(?), ?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, usuario.getNombre());
            stmt.setString(2, usuario.getApellido());
            stmt.setString(3, usuario.getEmail());
            stmt.setString(4, usuario.getPassword());
            stmt.setString(5, usuario.getRol());
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                stmt.setString(6, admin.getAreaGestion());
                stmt.setInt(7, admin.getNivelAcceso());
                stmt.setNull(8, Types.INTEGER);
                stmt.setNull(9, Types.VARCHAR);
                stmt.setNull(10, Types.VARCHAR);
                stmt.setNull(11, Types.DOUBLE);
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                stmt.setNull(6, Types.VARCHAR);
                stmt.setNull(7, Types.INTEGER);
                stmt.setInt(8, cliente.getPuntosAcumulados());
                stmt.setString(9, cliente.getTipoMembresia());
                stmt.setNull(10, Types.VARCHAR);
                stmt.setDouble(11, cliente.getSaldo());
            }
            int filasAfectadas = stmt.executeUpdate();
            return filasAfectadas > 0;
        } catch (SQLException e) {
            System.err.println("Error al insertar usuario: " + e.getMessage());
            return false;
        }
    }
}
\end{javacode}

\subsection{Servlets (Controladores)}

\subsubsection{ServletLogin.java}

\begin{javacode}{ServletLogin.java}
package com.cafeteria.controlador;
import com.cafeteria.dao.UsuarioDAO;
import com.cafeteria.modelo.*;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
@WebServlet(name = "ServletLogin", urlPatterns = {"/ServletLogin"})
public class ServletLogin extends HttpServlet {
    private UsuarioDAO usuarioDAO = new UsuarioDAO();
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String accion = request.getParameter("accion");
        if ("login".equals(accion)) login(request, response);
        else if ("registro".equals(accion)) registro(request, response);
        else if ("logout".equals(accion)) logout(request, response);
    }
    private void login(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        Usuario usuario = usuarioDAO.autenticar(email, password);
        if (usuario != null) {
            HttpSession session = request.getSession();
            session.setAttribute("usuario", usuario);
            session.setAttribute("idUsuario", usuario.getIdUsuario());
            session.setAttribute("nombreUsuario", usuario.getNombreCompleto());
            session.setAttribute("rol", usuario.getRol());
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                session.setAttribute("areaGestion", admin.getAreaGestion());
                session.setAttribute("nivelAcceso", admin.getNivelAcceso());
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                session.setAttribute("puntosAcumulados", cliente.getPuntosAcumulados());
                session.setAttribute("tipoMembresia", cliente.getTipoMembresia());
            }
            if (usuario instanceof Administrador || usuario instanceof Cajero) {
                response.sendRedirect("dashboard.jsp");
            } else {
                response.sendRedirect("menu.jsp");
            }
        } else {
            request.setAttribute("error", "Email o contraseña incorrectos");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        }
    }
    private void registro(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String nombre = request.getParameter("nombre");
        String apellido = request.getParameter("apellido");
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        String confirmarPassword = request.getParameter("confirmarPassword");
        if (!password.equals(confirmarPassword)) {
            request.setAttribute("error", "Las contraseñas no coinciden");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
            return;
        }
        Cliente cliente = new Cliente(nombre, apellido, email, password);
        boolean registrado = usuarioDAO.insertar(cliente);
        if (registrado) {
            request.setAttribute("mensaje", "Registro exitoso. Ya puedes iniciar sesión.");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        } else {
            request.setAttribute("error", "Error al registrar. El email podría estar en uso.");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
        }
    }
    private void logout(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        HttpSession session = request.getSession(false);
        if (session != null) session.invalidate();
        response.sendRedirect("index.jsp");
    }
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }
}
\end{javacode}

\section{Resultados y Pruebas}

\subsection{Interfaz de Usuario}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/login.png}
\caption{Pantalla de login del sistema}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/menu.png}
\caption{Menú principal con productos disponibles}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/carrito.png}
\caption{Carrito de compras con productos seleccionados}
\end{figure}

\subsection{Base de Datos}

\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[width=1.0\linewidth, height=0.85\textheight, keepaspectratio]{img/diagrama_bd.png}
\caption{Diagrama de la base de datos MySQL}
\end{figure}
\end{landscape}

\section{Conclusiones}

El desarrollo del Sistema de Gestión de Cafetín Universitario ha permitido aplicar de manera práctica los conceptos fundamentales de la Programación Orientada a Objetos en un contexto real de desarrollo de software. La implementación exitosa del sistema demuestra la efectividad de los principios POO como herramientas para crear aplicaciones modulares, mantenibles y escalables.

La herencia y el polimorfismo se evidenciaron claramente en la jerarquía de usuarios, donde la clase abstracta Usuario proporcionó una base común para las especializaciones Administrador, Cajero y Cliente. Este diseño permitió tratar a todos los tipos de usuarios de manera uniforme cuando se requería, mientras se aprovechaban sus comportamientos específicos cuando era necesario.

El encapsulamiento se aplicó consistentemente en todas las clases del modelo, protegiendo los atributos mediante modificadores de acceso privados y exponiendo únicamente métodos públicos para interactuar con los objetos. Esta práctica contribuyó significativamente a la robustez del sistema y facilitó la detección y corrección de errores.

La integración de tecnologías web (Servlets y JSP) con la base de datos MySQL a través del patrón DAO demostró la importancia de separar responsabilidades en capas bien definidas. La arquitectura MVC implementada permitió un desarrollo organizado y colaborativo, donde cambios en la interfaz de usuario no afectaron la lógica de negocio y viceversa.

El sistema desarrollado no solo cumple con los requisitos funcionales especificados, sino que también incorpora características avanzadas como sistema de membresías, control de inventario inteligente y gestión de múltiples roles de usuario. Estas funcionalidades adicionales enriquecen la experiencia del usuario final y proporcionan herramientas valiosas para la administración del cafetín.

En conclusión, el proyecto representa una aplicación completa de los principios de POO en un sistema real, demostrando cómo los conceptos teóricos se traducen en soluciones prácticas y funcionales. El conocimiento adquirido durante este desarrollo será fundamental para enfrentar desafíos más complejos en futuros proyectos de software.

\section{Referencias}

\begin{thebibliography}{99}
\bibitem{booch2007} Booch, G., Maksimchuk, R. A., Engle, M. W., Young, B. J., Conallen, J., \& Houston, K. A. (2007). \emph{Object-Oriented Analysis and Design with Applications}. Addison-Wesley Professional.
\bibitem{bloch2018} Bloch, J. (2018). \emph{Effective Java}. Addison-Wesley Professional.
\bibitem{martin2008} Martin, R. C. (2008). \emph{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.
\bibitem{gamma1994} Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \emph{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.
\bibitem{walls2015} Walls, C. (2015). \emph{Spring in Action}. Manning Publications.
\bibitem{alur2003} Alur, D., Malks, D., \& Crupi, J. (2003). \emph{Core J2EE Patterns: Best Practices and Design Strategies}. Prentice Hall.
\bibitem{bauer2015} Bauer, C., \& King, G. (2015). \emph{Java Persistence with Hibernate}. Manning Publications.
\bibitem{hall2011} Hall, M. (2011). \emph{Core Servlets and JavaServer Pages}. Prentice Hall.
\bibitem{oracle2020} Oracle Corporation. (2020). \emph{Java EE 8 Tutorial}. Oracle Press.
\bibitem{dubois2013} Dubois, P. (2013). \emph{MySQL Cookbook}. O'Reilly Media.
\bibitem{schwartz2012} Schwartz, B., Zaitsev, P., \& Tkachenko, V. (2012). \emph{High Performance MySQL}. O'Reilly Media.
\bibitem{larman2004} Larman, C. (2004). \emph{Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development}. Prentice Hall.
\bibitem{fowler2003} Fowler, M. (2003). \emph{UML Distilled: A Brief Guide to the Standard Object Modeling Language}. Addison-Wesley Professional.
\end{thebibliography}


\end{document}




\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor} 
\usepackage{listings}  % SOLO ESTE paquete para código

\geometry{left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm}
\setstretch{1.5}
\setlength{\parindent}{1.27cm}

% Configuración MUY SIMPLE para código
\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{gray!10},
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    tabsize=4,
    showstringspaces=false
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    citecolor=black
}

\newcommand{\coursename}{Escuela Profesional de Ingeniería de Sistemas e Informática}
\newcommand{\reportname}{Producto Final de la Segunda Unidad}
\newcommand{\reporttitle}{Sistema de Gestión de Cafetín}
\newcommand{\studentname}{Angiely Nina Choque}
\newcommand{\teachername}{Honorio Apaza Alanoca}
\newcommand{\subjectname}{Programación Orientada a Objetos II}

\pagestyle{fancy}
\fancyhf{} % Limpia todo
\fancyhead[R]{%
    \begin{tabular}[t]{r}
        \textbf{Universidad Nacional de Moquegua} \\
        \coursename
    \end{tabular}
}
\fancyfoot[R]{Pág. \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{titlepage}
\centering
\textbf{\Large UNIVERSIDAD NACIONAL DE MOQUEGUA}\\[0.5cm]
\textbf{\Large Facultad de Ingeniería y Arquitectura}\\[0.5cm]
\textbf{\large Escuela Profesional de Ingeniería de Sistemas e Informática}\\[0.8cm]
\includegraphics[scale=.28]{img/logo.png}\\[0.5cm]
\textbf{\Large \reporttitle}\\[0.5cm]
\textbf{\large \reportname}\\[1.0cm]
\textbf{\large Estudiante:}\\[0.2cm]
\studentname\\[0.7cm]
\textbf{\large Docente:}\\[0.2cm]
\teachername\\[0.7cm]
\textbf{\large Curso:}\\[0.2cm]
\subjectname\\[1.0cm]
\textbf{\large \today}\\[1.5cm]
\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación y contexto}

El presente proyecto representa el producto final de la segunda unidad de Programación Orientada a Objetos II, donde se integran los conocimientos fundamentales de POO con tecnologías web y bases de datos relacionales. La motivación principal consiste en desarrollar un sistema completo de gestión para un cafetín que resuelva problemáticas reales de negocios de comida, permitiendo la consolidación de conceptos teóricos mediante su implementación práctica en una aplicación web funcional.

\textbf{Problemática identificada:} Los cafetines tradicionales enfrentan diversos desafíos operativos que afectan su eficiencia y rentabilidad. Entre los principales problemas se encuentran: (1) la gestión manual de pedidos que genera errores, pérdida de órdenes y tiempos de espera prolongados; (2) el control deficiente del inventario que resulta en desabastecimiento de productos populares o pérdidas por vencimiento; (3) la ausencia de sistemas de fidelización de clientes que permitan conocer preferencias y generar estrategias de retención; (4) la dificultad para generar reportes de ventas, productos más solicitados y análisis de rentabilidad; y (5) la falta de diferenciación de roles y permisos entre empleados, exponiendo el negocio a riesgos de seguridad.

Este sistema aborda estas problemáticas mediante una solución integral que digitaliza los procesos críticos del negocio. A diferencia del prototipo inicial que trabajaba únicamente con clases en memoria, esta versión incorpora persistencia de datos mediante MySQL, arquitectura MVC (Modelo-Vista-Controlador), y una interfaz web desarrollada con JSP y Servlets. El resultado es una aplicación empresarial escalable que demuestra la aplicación práctica de patrones de diseño y buenas prácticas de desarrollo.

El sistema ``Sistema de Gestión de Cafetín'' permite gestionar tres tipos de usuarios diferenciados mediante herencia: administradores con acceso completo al sistema, cajeros que procesan pedidos, y clientes que realizan compras con un sistema de membresías y puntos de fidelización. Esta diferenciación de roles ejemplifica el uso del polimorfismo y la abstracción en un contexto real, donde cada tipo de usuario tiene comportamientos y permisos específicos, resolviendo así la problemática de control de accesos y permitiendo operaciones seguras y auditables.

\section{Marco Teórico}

\subsection{Programación Orientada a Objetos (POO)}

La Programación Orientada a Objetos es un paradigma que organiza el software en torno a objetos que contienen datos y comportamientos. Se fundamenta en cuatro principios esenciales \cite{booch2007}:

El \textbf{encapsulamiento} oculta los detalles internos de un objeto, exponiendo solo una interfaz pública. En Java, esto se logra mediante modificadores de acceso (private, protected, public) que controlan la visibilidad de atributos y métodos.

La \textbf{herencia} permite crear nuevas clases basándose en clases existentes, heredando sus atributos y métodos. En el sistema desarrollado, la clase abstracta Usuario sirve como base para Administrador, Cajero y Cliente \cite{bloch2018}.

El \textbf{polimorfismo} permite que objetos de diferentes clases respondan al mismo mensaje de manera particular. En Java, esto se manifiesta mediante sobrecarga y redefinición de métodos.

La \textbf{abstracción} identifica las características esenciales de un objeto. Las clases abstractas e interfaces en Java permiten definir contratos de comportamiento sin especificar la implementación \cite{martin2008}.

\subsection{Diagramas UML}

El Lenguaje Unificado de Modelado (UML) es un estándar para visualizar y documentar sistemas software \cite{fowler2003}. Los diagramas de clases muestran la estructura del sistema mediante clases, atributos, métodos y relaciones, representando cada clase como un rectángulo dividido en tres secciones. Los modificadores de visibilidad se indican con símbolos: + (público), - (privado), \# (protegido).

\subsection{Relaciones entre Clases en POO}

Las relaciones entre clases definen cómo los objetos interactúan en un sistema \cite{larman2004}:

La \textbf{asociación} indica que dos clases están conectadas, pudiendo ser unidireccional o bidireccional, con multiplicidad específica (uno-a-uno, uno-a-muchos, muchos-a-muchos).

La \textbf{agregación} representa una relación ``todo-parte'' donde las partes pueden existir independientemente del todo.

La \textbf{composición} es una agregación fuerte donde las partes dependen completamente del todo. En el sistema, la relación entre Pedido y DetallePedido es de composición.

La \textbf{herencia} establece una relación ``es-un'' entre una clase padre y sus clases hijas, permitiendo reutilización de código y polimorfismo.

\subsection{MySQL y Bases de Datos Relacionales}

MySQL es un sistema de gestión de bases de datos relacionales que organiza la información en tablas relacionadas mediante claves primarias y foráneas \cite{dubois2013}. Utiliza SQL para realizar operaciones como SELECT, INSERT, UPDATE y DELETE. La normalización minimiza la redundancia organizando las tablas según formas normales (1FN, 2FN, 3FN) \cite{schwartz2012}.

\textbf{XAMPP} es una distribución que incluye MySQL, facilitando la instalación de un entorno de desarrollo local con phpMyAdmin para gestionar la base de datos.

\subsection{Entorno de Desarrollo Java Web}

Apache NetBeans es un IDE que proporciona herramientas para el desarrollo de aplicaciones Java, con soporte para Servlets, JSP y JDBC \cite{oracle2020}. Para este proyecto se utilizó \textbf{Java Web con Ant}, una herramienta de automatización basada en XML que permite definir procesos de compilación y despliegue personalizados.

Apache Tomcat es un contenedor de servlets que implementa las especificaciones Java Servlet y JSP \cite{hall2011}. Actúa como intermediario entre el navegador y la aplicación Java, gestionando el ciclo de vida de servlets, sesiones HTTP y conexiones a bases de datos.

\subsection{Patrón de Arquitectura MVC}

El patrón Modelo-Vista-Controlador separa la lógica de negocio, la presentación y el control de flujo \cite{gamma1994}:

El \textbf{Modelo} representa la lógica de negocio y los datos, conteniendo las clases del dominio (Usuario, Producto, Pedido).

La \textbf{Vista} presenta la información al usuario mediante JSP, que combinan HTML con código Java para generar páginas dinámicas.

El \textbf{Controlador} procesa las peticiones del usuario mediante Servlets, invocando la lógica de negocio y seleccionando la vista apropiada \cite{walls2015}.

\subsection{Patrón DAO (Data Access Object)}

El patrón DAO encapsula toda la lógica de acceso a datos, separándola de la lógica de negocio \cite{alur2003}. Define operaciones CRUD (Create, Read, Update, Delete) para cada entidad, utilizando JDBC para interactuar con la base de datos y mapear resultados a objetos del modelo \cite{bauer2015}.

\subsection{Servlets y JSP}

Los Servlets son componentes Java del servidor que procesan peticiones HTTP mediante métodos doGet() y doPost() \cite{hall2011}. Las JSP simplifican la creación de contenido dinámico mezclando HTML con código Java, compilándose automáticamente en Servlets.

La combinación de Servlets (controladores) y JSP (vistas) implementa naturalmente el patrón MVC, permitiendo desarrollo ágil y separación clara de responsabilidades.

\section{Análisis y Diseño}

\subsection{Diagrama de Clases del Modelo}

El diagrama de clases del modelo representa la estructura fundamental del sistema, mostrando las entidades principales del dominio, sus atributos, métodos y las relaciones entre ellas. Este diagrama constituye el núcleo de la aplicación, ya que en estas clases se aplican directamente los conceptos de herencia, polimorfismo, encapsulamiento y abstracción estudiados en el curso.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/diagramUML.png}
\caption{Diagrama de clases del modelo del sistema}
\label{fig:diagrama-clases}
\end{figure}

El diagrama presenta las clases principales que modelan el dominio del negocio:

\begin{itemize}
    \item \textbf{Usuario (abstracta)}: Clase base que define la estructura común para todos los tipos de usuarios
    \item \textbf{Administrador, Cajero, Cliente}: Clases especializadas que heredan de Usuario
    \item \textbf{Producto}: Representa los artículos disponibles en el cafetín
    \item \textbf{Pedido}: Modela las órdenes realizadas por los clientes
    \item \textbf{DetallePedido}: Representa cada línea de un pedido con su producto y cantidad
\end{itemize}

Este diseño permite una clara separación de responsabilidades y facilita la extensibilidad del sistema, ya que agregar nuevos tipos de usuarios o entidades solo requiere crear nuevas clases que sigan la estructura establecida.

\subsection{Explicación de las Relaciones entre Clases}

Las relaciones entre clases definen cómo los objetos del sistema interactúan entre sí, con implicaciones específicas en la implementación.

\subsubsection{Herencia en la jerarquía de Usuario}

La clase abstracta \texttt{Usuario} define la estructura común para todos los tipos de usuarios. Las clases \texttt{Administrador}, \texttt{Cajero} y \texttt{Cliente} heredan de \texttt{Usuario}, especializando su funcionalidad según el rol. Esta herencia permite aplicar \textbf{polimorfismo}, donde un método puede trabajar con cualquier tipo de Usuario invocando métodos abstractos que cada subclase implementa de forma particular.

\texttt{Usuario} es abstracta porque no tiene sentido crear instancias genéricas; todo usuario debe tener un rol específico. Los métodos abstractos como \texttt{mostrarInfo()}, \texttt{calcularAcceso()} y \texttt{getRol()} obligan a cada subclase a proporcionar su implementación, garantizando comportamiento específico.

\subsubsection{Asociación entre Cliente y Pedido}

Un \texttt{Cliente} puede realizar múltiples \texttt{Pedidos}, estableciendo una relación \textbf{uno-a-muchos} (1..*). Esta asociación se implementa mediante \texttt{idUsuario} en \texttt{Pedido}, que funciona como clave foránea referenciando al cliente.

La relación es \textbf{unidireccional} desde \texttt{Pedido} hacia \texttt{Cliente}: los pedidos necesitan saber quién los realizó, pero un cliente no mantiene lista de sus pedidos en memoria (se consulta desde la base de datos cuando es necesario), optimizando memoria y evitando inconsistencias.

\subsubsection{Composición entre Pedido y DetallePedido}

Un \texttt{Pedido} se compone de múltiples \texttt{DetallePedido}, donde cada detalle representa un producto con su cantidad y precio. Esta es una relación de \textbf{composición fuerte} (rombo relleno en UML) porque los detalles no pueden existir sin un pedido, si se elimina un pedido se eliminan sus detalles, y el ciclo de vida de los detalles está controlado por el pedido.

\texttt{Pedido} mantiene una lista (\texttt{List<DetallePedido>}) de sus detalles, permitiendo gestionar todos los productos como una unidad y facilitar el cálculo del total del pedido.

\subsubsection{Asociación entre DetallePedido y Producto}

Cada \texttt{DetallePedido} referencia al \texttt{Producto} mediante \texttt{idProducto}. Esta es una \textbf{asociación simple}, ya que el detalle necesita conocer el producto para obtener su información, pero no posee ni controla su ciclo de vida; los productos existen independientemente de los pedidos.

Cuando se crea un detalle de pedido, se captura y almacena el \texttt{precioUnitario} del producto en ese momento, garantizando que cambios futuros en el precio no afecten pedidos históricos, manteniendo la integridad de los registros.

\subsection{Modelo de Base de Datos}

El modelo de base de datos representa el esquema relacional que persiste la información del sistema. Este diseño implementa las entidades del modelo orientado a objetos mediante tablas relacionales, aplicando principios de normalización para garantizar la integridad y eficiencia de los datos.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{img/diagramaBD.png}
\caption{Diagrama entidad-relación de la base de datos}
\label{fig:diagrama-bd}
\end{figure}

\subsubsection{Descripción de las Tablas Principales}

\paragraph{Tabla USUARIOS}
Almacena la información de todos los usuarios del sistema, implementando una estrategia de \textbf{tabla única para jerarquía de herencia} (Single Table Inheritance). Esta tabla contiene:

\begin{itemize}
    \item Atributos comunes: \texttt{id\_usuario}, \texttt{nombre}, \texttt{apellido}, \texttt{email}, \texttt{password}, \texttt{rol}, \texttt{fecha\_registro}, \texttt{activo}
    \item Atributos específicos de Administrador: \texttt{area\_gestion}, \texttt{nivel\_acceso}
    \item Atributos específicos de Cliente: \texttt{puntos\_acumulados}, \texttt{tipo\_membresia}, \texttt{saldo}
    \item Atributos específicos de Cajero: \texttt{turno}, \texttt{ventas\_diarias}
\end{itemize}

El campo \texttt{rol} actúa como discriminador para identificar el tipo específico de usuario. Los atributos no aplicables a un rol se mantienen como NULL. Esta estrategia simplifica las consultas y evita múltiples JOINs, aunque sacrifica algo de normalización.

\paragraph{Tabla PRODUCTOS}
Contiene el catálogo de productos disponibles en el cafetín. Incluye información descriptiva (\texttt{nombre}, \texttt{descripcion}), comercial (\texttt{precio}, \texttt{categoria}), y de disponibilidad (\texttt{stock}, \texttt{disponible}). Los campos \texttt{fecha\_creacion} y \texttt{fecha\_actualizacion} permiten auditoría de cambios.

\paragraph{Tabla PEDIDOS}
Registra las órdenes realizadas por los clientes. Cada pedido está vinculado a un usuario mediante \texttt{id\_usuario} (clave foránea), contiene información temporal (\texttt{fecha\_pedido}), financiera (\texttt{total}, \texttt{metodo\_pago}), y de seguimiento (\texttt{estado}, \texttt{observaciones}).

\paragraph{Tabla DETALLE\_PEDIDOS}
Implementa la relación muchos-a-muchos entre PEDIDOS y PRODUCTOS, almacenando los productos específicos de cada pedido. Cada registro contiene \texttt{cantidad}, \texttt{precio\_unitario} (capturado en el momento de la orden), y \texttt{subtotal} calculado. Esta tabla es esencial para mantener el histórico exacto de las transacciones.

\paragraph{Tabla INVENTARIO}
Gestiona los niveles de stock de cada producto, estableciendo umbrales mínimos y máximos (\texttt{cantidad\_minima}, \texttt{cantidad\_maxima}) para alertas de reabastecimiento. La relación uno-a-uno con PRODUCTOS se implementa mediante una clave foránea única (\texttt{id\_producto}).

\paragraph{Tabla MOVIMIENTOS\_INVENTARIO}
Registra todos los cambios en el inventario para auditoría y trazabilidad. Cada movimiento especifica el \texttt{tipo\_movimiento} (entrada, salida, ajuste), la \texttt{cantidad} afectada, el \texttt{motivo}, y opcionalmente el usuario responsable. Esta tabla es crucial para el control de inventario y detección de discrepancias.

\paragraph{Tabla REPORTES}
Almacena reportes generados por los administradores, incluyendo el \texttt{tipo\_reporte}, \texttt{fecha\_generacion}, y el \texttt{contenido} serializado. Esta tabla permite mantener un historial de análisis y facilita la generación de reportes recurrentes.

\subsubsection{Relaciones e Integridad Referencial}

El esquema implementa las siguientes relaciones mediante claves foráneas:

\begin{itemize}
    \item \textbf{USUARIOS $\rightarrow$ PEDIDOS}: Un usuario puede realizar múltiples pedidos (1:N)
    \item \textbf{PEDIDOS $\rightarrow$ DETALLE\_PEDIDOS}: Un pedido contiene múltiples detalles (1:N) con \texttt{ON DELETE CASCADE}
    \item \textbf{PRODUCTOS $\rightarrow$ DETALLE\_PEDIDOS}: Un producto puede aparecer en múltiples detalles (1:N)
    \item \textbf{PRODUCTOS $\rightarrow$ INVENTARIO}: Relación uno-a-uno estricta mediante clave foránea única
    \item \textbf{PRODUCTOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Trazabilidad de cambios (1:N)
    \item \textbf{USUARIOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Auditoría de responsables (1:N, nullable)
    \item \textbf{USUARIOS $\rightarrow$ REPORTES}: Trazabilidad de generación (1:N, nullable)
\end{itemize}

Las restricciones \texttt{ON DELETE CASCADE} en DETALLE\_PEDIDOS garantizan que al eliminar un pedido, sus detalles se eliminen automáticamente, manteniendo la coherencia de los datos y reflejando la relación de composición del modelo orientado a objetos.

\subsubsection{Normalización y Optimización}

El esquema de base de datos se encuentra en \textbf{Tercera Forma Normal (3FN)}:

\begin{itemize}
    \item \textbf{1FN}: Todos los atributos contienen valores atómicos, sin grupos repetitivos
    \item \textbf{2FN}: No existen dependencias parciales; todos los atributos no clave dependen completamente de la clave primaria
    \item \textbf{3FN}: No existen dependencias transitivas; los atributos no clave no dependen de otros atributos no clave
\end{itemize}

Se han definido índices sobre las columnas más consultadas (\texttt{email} en USUARIOS, \texttt{id\_producto} en INVENTARIO) para optimizar el rendimiento de las búsquedas frecuentes.

\subsection{Arquitectura del Sistema: Patrón MVC}

El sistema implementa el patrón de arquitectura Modelo-Vista-Controlador (MVC), que organiza la aplicación en tres capas independientes e interconectadas. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y permite que diferentes componentes evolucionen de forma independiente sin afectar al resto del sistema.

\subsubsection{Diseño Conceptual de la Arquitectura}

La arquitectura MVC se implementa mediante cuatro capas principales que se comunican siguiendo un flujo unidireccional:

\begin{itemize}
    \item \textbf{Capa de Presentación (Vista):} Responsable de la interfaz de usuario y presentación de datos. Recibe las peticiones del usuario y muestra los resultados.
    
    \item \textbf{Capa de Control (Controlador):} Actúa como intermediario entre la vista y el modelo. Procesa las peticiones del usuario, invoca la lógica de negocio y decide qué vista mostrar.
    
    \item \textbf{Capa de Modelo (Lógica de Negocio):} Contiene las reglas de negocio y la lógica de la aplicación. Incluye las entidades del dominio y sus comportamientos.
    
    \item \textbf{Capa de Persistencia (Base de Datos):} Almacena y recupera los datos de la aplicación en una base de datos relacional.
\end{itemize}

\subsubsection{Flujo de Comunicación entre Capas}

El flujo de una operación típica sigue estos pasos:

\begin{enumerate}
    \item El usuario interactúa con la \textbf{Vista} (página web)
    \item La Vista envía una petición HTTP al \textbf{Controlador}
    \item El Controlador procesa la petición y llama a los métodos apropiados del \textbf{Modelo}
    \item El Modelo ejecuta la lógica de negocio y accede a la \textbf{Base de Datos} si es necesario
    \item El Modelo retorna los resultados al Controlador
    \item El Controlador selecciona la Vista apropiada y le pasa los datos
    \item La Vista presenta los resultados al usuario
\end{enumerate}

\subsubsection{Decisiones de Diseño}

Se tomaron las siguientes decisiones clave en el diseño:

\begin{itemize}
    \item \textbf{Separación estricta de responsabilidades:} Cada capa tiene responsabilidades claramente definidas y no puede acceder directamente a capas no adyacentes.
    
    \item \textbf{Uso de patrones de diseño:} Se aplicaron los patrones Singleton (para conexiones a BD), DAO (para acceso a datos), y Factory (para creación de objetos).
    
    \item \textbf{Jerarquía de usuarios mediante herencia:} Se diseñó una clase abstracta Usuario como base para Administrador, Cajero y Cliente, permitiendo polimorfismo.
    
    \item \textbf{Composición para relaciones fuertes:} La relación Pedido-DetallePedido se diseñó como composición, reflejando que los detalles no existen sin el pedido.
    
    \item \textbf{Normalización de base de datos:} El esquema de BD sigue la tercera forma normal para evitar redundancias.
\end{itemize}

\subsubsection{Componentes por Capa}

\begin{table}[H]
\centering
\caption{Componentes por capa en la arquitectura MVC}
\label{tab:componentes-capa}
\begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Capa} & \textbf{Responsabilidades} & \textbf{Tecnologías/Patrones} \\
\hline
\hline
Presentación (Vista) & Interfaz de usuario, formularios, presentación de datos & JSP, HTML, CSS, JavaScript \\
\hline
Control (Controlador) & Enrutamiento, validación, gestión de sesiones, seguridad & Servlets, Filtros, Listeners \\
\hline
Modelo (Lógica) & Reglas de negocio, entidades, validaciones & Clases Java, POO, Patrones DAO \\
\hline
Persistencia (BD) & Almacenamiento, recuperación, integridad de datos & MySQL, JDBC, SQL \\
\hline
\end{tabular}
\end{table}

\section{Implementación}

\subsection{Arquitectura Implementada}

A continuación se muestran las implementaciones concretas de cada capa del sistema:

\subsubsection{Capa de Presentación - Vistas JSP}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-vista.png}
\caption{Implementación de la capa de presentación con páginas JSP}
\label{fig:impl-vista}
\end{figure}

La capa de presentación se implementó mediante 12 páginas JSP organizadas en tres módulos: autenticación, cliente y administración. Cada página sigue una plantilla común con cabecera, menú y pie de página para mantener consistencia visual.

\subsubsection{Capa de Control - Servlets}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-control.png}
\caption{Implementación de la capa de control con Servlets}
\label{fig:impl-control}
\end{figure}

Se implementaron 4 Servlets principales que manejan las diferentes funcionalidades del sistema. Cada Servlet sigue el patrón: recibir parámetros → validar → procesar → redirigir.

\subsubsection{Capa de Modelo - Clases y DAOs}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-modelo.png}
\caption{Implementación de la capa de modelo con clases Java y DAOs}
\label{fig:impl-modelo}
\end{figure}

El modelo se implementó mediante 8 clases principales y 4 DAOs. La jerarquía de Usuario demuestra la aplicación práctica de herencia y polimorfismo.

\subsubsection{Capa de Persistencia - Base de Datos}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-persistencia.png}
\caption{Implementación de la capa de persistencia con MySQL}
\label{fig:impl-persistencia}
\end{figure}

La base de datos se implementó con 4 tablas principales relacionadas mediante claves foráneas, siguiendo principios de normalización.

\subsection{Clases del Modelo}

\subsubsection{Clase Usuario (abstracta)}

\begin{lstlisting}[caption=Usuario.java - Clase abstracta base, label=lst:usuario]
package com.cafeteria.modelo;
import java.sql.Timestamp;

public abstract class Usuario {
    protected int idUsuario;
    protected String nombre;
    protected String apellido;
    protected String email;
    protected String password;
    protected Timestamp fechaRegistro;
    protected boolean activo;

    public Usuario(String nombre, String apellido, 
                   String email, String password) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.email = email;
        this.password = password;
        this.activo = true;
    }

    public abstract String mostrarInfo();
    public abstract String calcularAcceso();
    public abstract String getRol();
}
\end{lstlisting}

\subsubsection{Clase Cliente}

\begin{lstlisting}[caption=Cliente.java - Implementación concreta, label=lst:cliente]
package com.cafeteria.modelo;

public class Cliente extends Usuario {
    private int puntosAcumulados;
    private String tipoMembresia;
    private double saldo;

    public Cliente(String nombre, String apellido, 
                   String email, String password) {
        super(nombre, apellido, email, password);
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }

    public boolean realizarCompra(double totalCompra) {
        if (!tieneSaldoSuficiente(totalCompra)) {
            return false;
        }
        this.saldo -= totalCompra;
        acumularPuntos(totalCompra);
        return true;
    }
}
\end{lstlisting}

\subsubsection{Clase Producto}

\begin{lstlisting}[caption=Producto.java - Encapsulamiento, label=lst:producto]
package com.cafeteria.modelo;

public class Producto {
    private int idProducto;
    private String nombre;
    private String descripcion;
    private double precio;
    private int stock;
    private String categoria;
    private boolean disponible;
    private String imagen;

    public boolean hayStock() {
        return stock > 0 && disponible;
    }

    public void actualizarStock(int cantidad) {
        this.stock += cantidad;
        if (this.stock <= 0) {
            this.disponible = false;
        } else {
            this.disponible = true;
        }
    }
}
\end{lstlisting}

\subsection{Patrón DAO}

\subsubsection{ConexionBD.java}

\begin{lstlisting}[caption=ConexionBD.java - Singleton, label=lst:conexion]
package com.cafeteria.dao;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConexionBD {
    private static final String URL = "jdbc:mysql://localhost:3306/cafetin";
    private static final String USUARIO = "root";
    private static final String PASSWORD = "";
    private static Connection conexion = null;

    private ConexionBD() {}

    public static Connection getConexion() {
        try {
            if (conexion == null || conexion.isClosed()) {
                Class.forName("com.mysql.cj.jdbc.Driver");
                conexion = DriverManager.getConnection(URL, USUARIO, PASSWORD);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return conexion;
    }
}
\end{lstlisting}

\subsubsection{UsuarioDAO.java}

\begin{lstlisting}[caption=UsuarioDAO.java - Mapeo OR, label=lst:usuariodao]
package com.cafeteria.dao;
import com.cafeteria.modelo.*;
import java.sql.*;

public class UsuarioDAO {
    public Usuario autenticar(String email, String password) {
        Usuario usuario = null;
        String sql = "SELECT * FROM usuarios WHERE email = ? " +
                     "AND password = MD5(?) AND activo = true";
        
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, email);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                String rol = rs.getString("rol");
                
                switch (rol) {
                    case "administrador":
                        Administrador admin = new Administrador();
                        // ... mapeo de campos
                        usuario = admin;
                        break;
                    case "cliente":
                        Cliente cliente = new Cliente();
                        // ... mapeo de campos
                        usuario = cliente;
                        break;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return usuario;
    }
}
\end{lstlisting}

\subsection{Servlets}

\subsubsection{ServletLogin.java}

\begin{lstlisting}[caption=ServletLogin.java - Controlador, label=lst:servletlogin]
package com.cafeteria.controlador;
import com.cafeteria.dao.UsuarioDAO;
import com.cafeteria.modelo.*;
import java.io.IOException;
import javax.servlet.*;
import javax.servlet.http.*;

@WebServlet("/ServletLogin")
public class ServletLogin extends HttpServlet {
    private UsuarioDAO usuarioDAO = new UsuarioDAO();

    protected void doPost(HttpServletRequest request, 
                         HttpServletResponse response)
            throws ServletException, IOException {
        
        String accion = request.getParameter("accion");
        
        if ("login".equals(accion)) {
            String email = request.getParameter("email");
            String password = request.getParameter("password");
            
            Usuario usuario = usuarioDAO.autenticar(email, password);
            
            if (usuario != null) {
                HttpSession session = request.getSession();
                session.setAttribute("usuario", usuario);
                session.setAttribute("rol", usuario.getRol());
                
                if (usuario instanceof Administrador) {
                    response.sendRedirect("dashboard.jsp");
                } else {
                    response.sendRedirect("menu.jsp");
                }
            } else {
                request.setAttribute("error", "Credenciales incorrectas");
                request.getRequestDispatcher("login.jsp").forward(request, response);
            }
        }
    }
}
\end{lstlisting}

\section{Resultados y Pruebas}

\subsection{Funcionalidades Implementadas}

\begin{table}[H]
\centering
\caption{Funcionalidades Implementadas en el Sistema}
\label{tab:funcionalidades}
\begin{tabular}{|p{3.5cm}|p{12.5cm}|}
\hline
\textbf{Módulo} & \textbf{Funcionalidades Logradas} \\
\hline
\hline
\textbf{Autenticación y Gestión de Usuarios} & 
\begin{itemize}[leftmargin=*,nosep]
    \item Sistema de login seguro con encriptación MD5
    \item Registro de nuevos clientes con validación
    \item Gestión de sesiones HTTP con atributos específicos por rol
    \item Implementación de jerarquía de usuarios con herencia
\end{itemize} \\
\hline
\textbf{Gestión de Productos} &
\begin{itemize}[leftmargin=*,nosep]
    \item CRUD completo de productos con persistencia en MySQL
    \item Control de stock con actualización automática
    \item Categorización y filtrado de productos
    \item Sistema de disponibilidad automática según stock
\end{itemize} \\
\hline
\textbf{Sistema de Pedidos} &
\begin{itemize}[leftmargin=*,nosep]
    \item Carrito de compras con gestión de sesiones
    \item Cálculo automático de totales y subtotales
    \item Gestión de estados del pedido (pendiente, preparando, entregado)
    \item Validación de stock en tiempo real
    \item Generación de tickets de compra
\end{itemize} \\
\hline
\textbf{Sistema de Clientes y Membresías} &
\begin{itemize}[leftmargin=*,nosep]
    \item Acumulación de puntos por compras (1 punto por cada S/5)
    \item Sistema de membresías automático (Bronce, Plata, Oro)
    \item Descuentos progresivos según nivel de membresía
    \item Gestión de saldo electrónico
\end{itemize} \\
\hline
\textbf{Arquitectura y Diseño} &
\begin{itemize}[leftmargin=*,nosep]
    \item Implementación completa del patrón MVC
    \item Aplicación de principios POO (herencia, polimorfismo, encapsulamiento)
    \item Patrón DAO para abstracción de persistencia
    \item Patrón Singleton para gestión de conexiones
    \item Base de datos normalizada en 3FN
\end{itemize} \\
\hline
\end{tabular}
\end{table}

\subsection{Interfaces de Usuario Desarrolladas}

\subsubsection{Pantalla de Login}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/login.png}
\caption{Pantalla de login del sistema con validación de credenciales}
\label{fig:login}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Formulario de login con campos email y password
    \item Validación del lado del cliente (JavaScript) y servidor
    \item Encriptación MD5 de contraseñas
    \item Manejo de errores con mensajes personalizados
    \item Redirección según tipo de usuario (polimorfismo en acción)
\end{itemize}

\subsubsection{Menú Principal}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/menu.png}
\caption{Menú principal con productos categorizados y sistema de filtrado}
\label{fig:menu}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Visualización de productos por categorías
    \item Sistema de filtrado dinámico
    \item Información detallada de cada producto (precio, stock, descripción)
    \item Botones para agregar al carrito con selección de cantidad
    \item Diseño responsive y atractivo
\end{itemize}

\subsubsection{Carrito de Compras}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{img/carrito.png}
\caption{Carrito de compras con resumen de productos, cantidades y total}
\label{fig:carrito}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Gestión de carrito mediante sesiones HTTP
    \item Actualización dinámica de cantidades
    \item Cálculo automático de subtotales y total
    \item Aplicación automática de descuentos por membresía
    \item Validación de stock antes de confirmar compra
    \item Opciones para modificar o eliminar productos
\end{itemize}

\subsection{Resultados Técnicos Obtenidos}

\subsubsection{Aplicación Exitosa de Principios POO}

El proyecto demostró la aplicación efectiva de los principios fundamentales de Programación Orientada a Objetos:

\begin{itemize}
    \item \textbf{Herencia:} Implementada en la jerarquía Usuario → Administrador/Cajero/Cliente, permitiendo reutilización de código y especialización de comportamientos.
    
    \item \textbf{Polimorfismo:} Logrado mediante métodos abstractos en la clase Usuario que cada subclase implementa según su rol específico.
    
    \item \textbf{Encapsulamiento:} Aplicado consistentemente en todas las clases del modelo, protegiendo los atributos y exponiendo solo interfaces controladas.
    
    \item \textbf{Abstracción:} Utilizada en la definición de contratos mediante clases abstractas e interfaces.
\end{itemize}

\subsubsection{Arquitectura MVC Funcional}

Se implementó exitosamente una arquitectura Modelo-Vista-Controlador que proporciona:

\begin{itemize}
    \item \textbf{Separación clara de responsabilidades:} Cada capa tiene responsabilidades bien definidas y limitadas.
    
    \item \textbf{Mantenibilidad:} Cambios en una capa no afectan significativamente a las otras.
    
    \item \textbf{Escalabilidad:} La arquitectura permite agregar nuevas funcionalidades sin comprometer la estructura existente.
\end{itemize}

\subsubsection{Integración Exitosa de Tecnologías}

El proyecto logró integrar múltiples tecnologías de forma coherente:

\begin{itemize}
    \item \textbf{Java EE:} Para la lógica de negocio y controladores.
    
    \item \textbf{JSP:} Para la generación de vistas dinámicas.
    
    \item \textbf{MySQL:} Para el almacenamiento persistente de datos.
    
    \item \textbf{JDBC:} Para la comunicación entre Java y la base de datos.
    
    \item \textbf{HTML/CSS/JavaScript:} Para la interfaz de usuario y experiencia del cliente.
\end{itemize}

\subsubsection{Base de Datos Normalizada}

Se diseñó e implementó una base de datos relacional que cumple con:

\begin{itemize}
    \item \textbf{Tercera Forma Normal (3FN):} Eliminando redundancias y dependencias transitivas.
    
    \item \textbf{Integridad Referencial:} Implementada mediante claves foráneas y restricciones.
    
    \item \textbf{Optimización:} Índices en columnas frecuentemente consultadas para mejorar el rendimiento.
\end{itemize}

\subsection{Desafíos Superados}

Durante el desarrollo se enfrentaron y resolvieron los siguientes desafíos:

\begin{enumerate}
    \item \textbf{Mapeo objeto-relacional:} Se implementó con éxito el patrón DAO para mapear la jerarquía de herencia de Usuario a tablas relacionales.
    
    \item \textbf{Gestión de sesiones:} Se implementó un sistema robusto de manejo de sesiones HTTP con almacenamiento de estado de usuario.
    
    \item \textbf{Validación concurrente de stock:} Se desarrolló un mecanismo para evitar ventas de productos sin stock disponible.
    
    \item \textbf{Sistema de membresías dinámico:} Se implementó un algoritmo que actualiza automáticamente el nivel de membresía según puntos acumulados.
\end{enumerate}

\section{Conclusiones}

El desarrollo del Sistema de Gestión de Cafetín Universitario ha permitido aplicar de manera práctica los conceptos fundamentales de la Programación Orientada a Objetos en un contexto real de desarrollo de software. La implementación exitosa del sistema demuestra la efectividad de los principios POO como herramientas para crear aplicaciones modulares, mantenibles y escalables.

La herencia y el polimorfismo se evidenciaron claramente en la jerarquía de usuarios, donde la clase abstracta Usuario proporcionó una base común para las especializaciones Administrador, Cajero y Cliente. Este diseño permitió tratar a todos los tipos de usuarios de manera uniforme cuando se requería, mientras se aprovechaban sus comportamientos específicos cuando era necesario.

El encapsulamiento se aplicó consistentemente en todas las clases del modelo, protegiendo los atributos mediante modificadores de acceso privados y exponiendo únicamente métodos públicos para interactuar con los objetos. Esta práctica contribuyó significativamente a la robustez del sistema y facilitó la detección y corrección de errores.

La integración de tecnologías web (Servlets y JSP) con la base de datos MySQL a través del patrón DAO demostró la importancia de separar responsabilidades en capas bien definidas. La arquitectura MVC implementada permitió un desarrollo organizado y colaborativo, donde cambios en la interfaz de usuario no afectaron la lógica de negocio y viceversa.

El sistema desarrollado no solo cumple con los requisitos funcionales especificados, sino que también incorpora características avanzadas como sistema de membresías, control de inventario inteligente y gestión de múltiples roles de usuario. Estas funcionalidades adicionales enriquecen la experiencia del usuario final y proporcionan herramientas valiosas para la administración del cafetín.

En conclusión, el proyecto representa una aplicación completa de los principios de POO en un sistema real, demostrando cómo los conceptos teóricos se traducen en soluciones prácticas y funcionales. El conocimiento adquirido durante este desarrollo será fundamental para enfrentar desafíos más complejos en futuros proyectos de software.

\begin{thebibliography}{99}
\bibitem{booch2007} Booch, G., Maksimchuk, R. A., Engle, M. W., Young, B. J., Conallen, J., \& Houston, K. A. (2007). \emph{Object-Oriented Analysis and Design with Applications}. Addison-Wesley Professional.

\bibitem{bloch2018} Bloch, J. (2018). \emph{Effective Java}. Addison-Wesley Professional.

\bibitem{martin2008} Martin, R. C. (2008). \emph{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.

\bibitem{gamma1994} Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \emph{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.

\bibitem{walls2015} Walls, C. (2015). \emph{Spring in Action}. Manning Publications.

\bibitem{alur2003} Alur, D., Malks, D., \& Crupi, J. (2003). \emph{Core J2EE Patterns: Best Practices and Design Strategies}. Prentice Hall.

\bibitem{bauer2015} Bauer, C., \& King, G. (2015). \emph{Java Persistence with Hibernate}. Manning Publications.

\bibitem{hall2011} Hall, M. (2011). \emph{Core Servlets and JavaServer Pages}. Prentice Hall.

\bibitem{oracle2020} Oracle Corporation. (2020). \emph{Java EE 8 Tutorial}. Oracle Press.

\bibitem{dubois2013} Dubois, P. (2013). \emph{MySQL Cookbook}. O'Reilly Media.

\bibitem{schwartz2012} Schwartz, B., Zaitsev, P., \& Tkachenko, V. (2012). \emph{High Performance MySQL}. O'Reilly Media.

\bibitem{larman2004} Larman, C. (2004). \emph{Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development}. Prentice Hall.

\bibitem{fowler2003} Fowler, M. (2003). \emph{UML Distilled: A Brief Guide to the Standard Object Modeling Language}. Addison-Wesley Professional.
\end{thebibliography}

\end{document}












% !TeX program = pdflatex --shell-escape
% !TeX TXS-program:pdflatex --shell-escape

\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{pdflscape}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{minted}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{array}

\geometry{left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm}
\setstretch{1.5}
\setlength{\parindent}{1.27cm}

% Configuración mejorada para listados de código
\definecolor{codebackground}{RGB}{248,248,248}
\definecolor{codekeyword}{RGB}{127,0,85}
\definecolor{codestring}{RGB}{42,0,255}
\definecolor{codecomment}{RGB}{63,127,95}
\definecolor{codeframe}{RGB}{200,200,200}

\tcbuselibrary{listings,skins,breakable}

\newtcblisting{javacode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=java,
    minted options={
        numbers=left,
        numbersep=6pt,
        fontsize=\footnotesize,
        breaklines=true,
        linenos=true,
        baselinestretch=1.3,
        tabsize=4,
        frame=lines,
        framesep=3mm,
        rulecolor=\color{codeframe}
    },
    colback=codebackground,
    colframe=codeframe,
    listing only,
    left=8mm,
    right=4mm,
    top=4mm,
    bottom=4mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries\small,
    breakable,
    #1
}

\newtcblisting{sqlcode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=sql,
    minted options={
        numbers=left,
        numbersep=6pt,
        fontsize=\footnotesize,
        breaklines=true,
        linenos=true,
        baselinestretch=1.3,
        tabsize=4,
        frame=lines,
        framesep=3mm,
        rulecolor=\color{codeframe}
    },
    colback=codebackground,
    colframe=codeframe,
    listing only,
    left=8mm,
    right=4mm,
    top=4mm,
    bottom=4mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries\small,
    breakable,
    #1
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=black
}

\newcommand{\coursename}{Escuela Profesional de Ingeniería de Sistemas e Informática}
\newcommand{\reportname}{Producto Final de la Segunda Unidad}
\newcommand{\reporttitle}{Sistema de Gestión de Cafetín}
\newcommand{\studentname}{Angiely Nina Choque}
\newcommand{\teachername}{Honorio Apaza Alanoca}
\newcommand{\subjectname}{Programación Orientada a Objetos II}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Universidad Nacional de Moquegua}
\fancyhead[R]{\coursename}
\fancyfoot[C]{Pág. \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\centering
\textsc{\Large \textbf{UNIVERSIDAD NACIONAL DE MOQUEGUA}}\\[0.5cm]
\textsc{\Large Facultad de Ingeniería y Arquitectura }\\[0.5cm]
\textsc{\large Escuela Profesional de Ingeniería de Sistemas e Informática}\\[0.8cm]
\includegraphics[scale=.28]{img/logo.png}\\[0.5cm] 
{ 
\Large{\bfseries{\reporttitle}}\\[0.5cm]
\large{\bfseries{\reportname}}
}\\[1.0cm]
\emph{\large Estudiante:}\\[0.2cm]
\studentname\\[0.7cm]
\emph{\large Docente:}\\[0.2cm]
\teachername\\[0.7cm]
\emph{\large Curso:}\\[0.2cm]
\subjectname\\[1.0cm]
{\large \today}\\[1.5cm]
\vfill
\end{titlepage}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación y contexto}

El presente proyecto representa el producto final de la segunda unidad de Programación Orientada a Objetos II, donde se integran los conocimientos fundamentales de POO con tecnologías web y bases de datos relacionales. La motivación principal consiste en desarrollar un sistema completo de gestión para un cafetín que resuelva problemáticas reales de negocios de comida, permitiendo la consolidación de conceptos teóricos mediante su implementación práctica en una aplicación web funcional.

\textbf{Problemática identificada:} Los cafetines tradicionales enfrentan diversos desafíos operativos que afectan su eficiencia y rentabilidad. Entre los principales problemas se encuentran: (1) la gestión manual de pedidos que genera errores, pérdida de órdenes y tiempos de espera prolongados; (2) el control deficiente del inventario que resulta en desabastecimiento de productos populares o pérdidas por vencimiento; (3) la ausencia de sistemas de fidelización de clientes que permitan conocer preferencias y generar estrategias de retención; (4) la dificultad para generar reportes de ventas, productos más solicitados y análisis de rentabilidad; y (5) la falta de diferenciación de roles y permisos entre empleados, exponiendo el negocio a riesgos de seguridad.

Este sistema aborda estas problemáticas mediante una solución integral que digitaliza los procesos críticos del negocio. A diferencia del prototipo inicial que trabajaba únicamente con clases en memoria, esta versión incorpora persistencia de datos mediante MySQL, arquitectura MVC (Modelo-Vista-Controlador), y una interfaz web desarrollada con JSP y Servlets. El resultado es una aplicación empresarial escalable que demuestra la aplicación práctica de patrones de diseño y buenas prácticas de desarrollo.

El sistema ``Sistema de Gestión de Cafetín'' permite gestionar tres tipos de usuarios diferenciados mediante herencia: administradores con acceso completo al sistema, cajeros que procesan pedidos, y clientes que realizan compras con un sistema de membresías y puntos de fidelización. Esta diferenciación de roles ejemplifica el uso del polimorfismo y la abstracción en un contexto real, donde cada tipo de usuario tiene comportamientos y permisos específicos, resolviendo así la problemática de control de accesos y permitiendo operaciones seguras y auditables.

\section{Marco Teórico}

\subsection{Programación Orientada a Objetos (POO)}

La Programación Orientada a Objetos es un paradigma de programación que organiza el diseño del software en torno a objetos que contienen tanto datos como comportamientos. Este paradigma se fundamenta en cuatro principios esenciales que permiten crear sistemas modulares, reutilizables y mantenibles \cite{booch2007}. A diferencia de la programación procedural, la POO permite modelar entidades del mundo real de manera más natural y expresiva.

El \textbf{encapsulamiento} consiste en ocultar los detalles internos de implementación de un objeto, exponiendo únicamente una interfaz pública para interactuar con él. En Java, esto se logra mediante modificadores de acceso (private, protected, public) que controlan la visibilidad de atributos y métodos. Este principio mejora la seguridad del código y facilita su mantenimiento, ya que los cambios internos no afectan al código que utiliza la clase.

La \textbf{herencia} es un mecanismo que permite crear nuevas clases basándose en clases existentes, heredando sus atributos y métodos. Esto promueve la reutilización de código y establece relaciones jerárquicas entre clases. En el sistema desarrollado, la clase abstracta Usuario sirve como clase base para Administrador, Cajero y Cliente, compartiendo funcionalidad común mientras permite especializaciones específicas \cite{bloch2018}.

El \textbf{polimorfismo} permite que objetos de diferentes clases respondan al mismo mensaje de manera particular según su tipo. En Java, esto se manifiesta mediante la sobrecarga de métodos (mismo nombre, diferentes parámetros) y la redefinición de métodos heredados. Este principio permite escribir código más flexible y extensible, como se evidencia en los métodos abstractos de la clase Usuario que cada subclase implementa de forma específica.

La \textbf{abstracción} es el proceso de identificar las características esenciales de un objeto, ignorando los detalles irrelevantes para el contexto. Las clases abstractas e interfaces en Java permiten definir contratos de comportamiento sin especificar la implementación, logrando un alto nivel de modularidad y bajo acoplamiento entre componentes \cite{martin2008}.

\subsection{Diagramas UML}

El Lenguaje Unificado de Modelado (UML) es un estándar para visualizar, especificar, construir y documentar artefactos de sistemas software \cite{fowler2003}. Los diagramas de clases son uno de los tipos más importantes de UML, mostrando la estructura estática del sistema mediante clases, atributos, métodos y relaciones.

Un diagrama de clases UML representa cada clase como un rectángulo dividido en tres secciones: nombre de la clase, atributos y métodos. Los modificadores de visibilidad se indican con símbolos: + para público, - para privado, \# para protegido. Las relaciones se representan mediante diferentes tipos de líneas: líneas sólidas para asociaciones, líneas con rombos para agregación y composición, y flechas con líneas continuas para herencia.

Los diagramas UML son fundamentales en las fases de análisis y diseño, permitiendo comunicar la estructura del sistema de forma visual e independiente del lenguaje de programación. Herramientas como PlantUML, draw.io y Mermaid permiten crear estos diagramas mediante código o interfaces gráficas, facilitando su actualización y versionado junto con el código fuente.

\subsection{Relaciones entre Clases en POO}

Las relaciones entre clases definen cómo los objetos interactúan y se conectan entre sí en un sistema orientado a objetos \cite{larman2004}. Existen varios tipos de relaciones, cada una con semántica y consecuencias diferentes en el diseño del sistema.

La \textbf{asociación} es la relación más general, indicando que dos clases están conectadas de alguna manera. Puede ser unidireccional (una clase conoce a la otra) o bidireccional (ambas se conocen mutuamente). Las asociaciones tienen multiplicidad, indicando cuántos objetos de cada clase participan en la relación (uno-a-uno, uno-a-muchos, muchos-a-muchos).

La \textbf{agregación} es un tipo especial de asociación que representa una relación ``todo-parte'' donde las partes pueden existir independientemente del todo. Por ejemplo, un Departamento contiene Empleados, pero los empleados pueden existir aunque se elimine el departamento. Esta relación implica una conexión débil entre los objetos participantes.

La \textbf{composición} es una forma fuerte de agregación donde las partes dependen completamente del todo para su existencia. Si el objeto contenedor se destruye, sus partes también lo hacen. En el sistema desarrollado, la relación entre Pedido y DetallePedido es de composición, ya que los detalles de un pedido no pueden existir sin el pedido que los contiene.

La \textbf{herencia} (también llamada generalización) establece una relación ``es-un'' entre una clase padre y sus clases hijas. Las subclases heredan todos los atributos y métodos de la superclase, pudiendo añadir funcionalidad específica o redefinir comportamientos heredados. Esta relación permite la reutilización de código y el polimorfismo, fundamentales para el diseño flexible de sistemas.

\subsection{MySQL y Bases de Datos Relacionales}

MySQL es un sistema de gestión de bases de datos relacionales (RDBMS) de código abierto ampliamente utilizado en aplicaciones web. Una base de datos relacional organiza la información en tablas relacionadas entre sí mediante claves primarias y foráneas, garantizando la integridad referencial y consistencia de los datos \cite{dubois2013}.

El modelo relacional se basa en la teoría de conjuntos y álgebra relacional, permitiendo realizar consultas complejas mediante SQL (Structured Query Language). Las operaciones básicas incluyen SELECT para consultas, INSERT para inserciones, UPDATE para actualizaciones y DELETE para eliminaciones. MySQL soporta características avanzadas como transacciones ACID, procedimientos almacenados, triggers, y vistas, que permiten implementar lógica compleja directamente en la base de datos \cite{schwartz2012}.

La normalización de bases de datos es un proceso mediante el cual se organizan las tablas para minimizar la redundancia y dependencias. Las formas normales (1FN, 2FN, 3FN) establecen reglas progresivamente más estrictas para el diseño de esquemas, mejorando la integridad y eficiencia de las consultas. El diseño adecuado de índices también es crucial para optimizar el rendimiento de las consultas frecuentes.

\textbf{XAMPP} es una distribución de Apache que incluye MySQL, PHP y Perl, facilitando la instalación y configuración de un entorno de desarrollo web local. Para este proyecto, se utilizó XAMPP para gestionar la base de datos MySQL, proporcionando una interfaz amigable a través de phpMyAdmin para la creación y administración de tablas, ejecución de consultas SQL, y respaldo de datos.

\subsection{Entorno de Desarrollo Java Web}

\subsubsection{Apache NetBeans y Java con Ant}

Apache NetBeans es un entorno de desarrollo integrado (IDE) de código abierto que proporciona herramientas completas para el desarrollo de aplicaciones Java, especialmente para aplicaciones empresariales y web \cite{oracle2020}. NetBeans incluye soporte nativo para tecnologías Java EE como Servlets, JSP, JDBC, y facilita la integración con servidores de aplicaciones.

Para este proyecto se utilizó \textbf{Java Web con Ant} como sistema de construcción. Apache Ant es una herramienta de automatización de compilación basada en XML que permite definir tareas de compilación, empaquetado y despliegue de aplicaciones Java. A diferencia de Maven o Gradle, Ant ofrece mayor flexibilidad en la definición de procesos de construcción personalizados, siendo ideal para proyectos académicos donde se requiere comprender cada paso del proceso de compilación y despliegue.

\subsubsection{Servidor Apache Tomcat}

Apache Tomcat es un servidor web y contenedor de servlets de código abierto que implementa las especificaciones Java Servlet, JavaServer Pages (JSP) y otras tecnologías Java EE \cite{hall2011}. Tomcat proporciona un entorno ``puro Java'' para ejecutar aplicaciones web, procesando peticiones HTTP y gestionando el ciclo de vida de servlets y páginas JSP.

El servidor Tomcat actúa como intermediario entre las peticiones del navegador web y la aplicación Java, proporcionando servicios esenciales como:
\begin{itemize}
    \item Gestión del ciclo de vida de servlets y JSP
    \item Manejo de sesiones HTTP
    \item Procesamiento de peticiones y respuestas
    \item Pool de conexiones a bases de datos
    \item Gestión de seguridad y autenticación
\end{itemize}

Para este proyecto, Tomcat fue configurado en NetBeans para permitir el despliegue automático de la aplicación durante el desarrollo, facilitando las pruebas y depuración del sistema.

\subsection{Patrón de Arquitectura MVC}

El patrón Modelo-Vista-Controlador (MVC) es una arquitectura de software que separa la lógica de negocio, la presentación y el control de flujo en tres componentes distintos e interconectados \cite{gamma1994}. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y el trabajo en equipo, ya que diferentes desarrolladores pueden trabajar en cada capa de forma independiente.

El \textbf{Modelo} representa la lógica de negocio y los datos de la aplicación. Contiene las clases que modelan las entidades del dominio (Usuario, Producto, Pedido) y encapsula las reglas de negocio. En el sistema desarrollado, las clases del paquete modelo implementan la estructura de datos y los métodos que operan sobre ellos, independientemente de cómo se presentan o controlan.

La \textbf{Vista} es responsable de la presentación de la información al usuario. En aplicaciones web Java, las vistas se implementan mediante JSP (JavaServer Pages), que combinan HTML con código Java para generar páginas dinámicas. Las vistas acceden al modelo únicamente para lectura, nunca para modificación directa, manteniendo la separación de responsabilidades.

El \textbf{Controlador} actúa como intermediario entre el modelo y la vista, procesando las peticiones del usuario, invocando la lógica de negocio apropiada, y seleccionando la vista adecuada para mostrar los resultados. En Java EE, los Servlets funcionan como controladores, recibiendo peticiones HTTP, interactuando con el modelo, y redirigiendo a las vistas JSP correspondientes \cite{walls2015}.

\subsection{Patrón DAO (Data Access Object)}

El patrón DAO proporciona una interfaz abstracta para acceder a datos de cualquier fuente, típicamente una base de datos relacional. Este patrón encapsula toda la lógica de acceso a datos, separándola completamente de la lógica de negocio \cite{alur2003}. Los beneficios principales incluyen la centralización del acceso a datos, facilidad para cambiar de tecnología de persistencia, y simplificación de las pruebas unitarias mediante la posibilidad de crear implementaciones simuladas.

Un DAO típico define operaciones CRUD (Create, Read, Update, Delete) para una entidad específica del dominio. Por ejemplo, UsuarioDAO proporciona métodos como insertar(), buscarPorId(), listarTodos(), actualizar() y eliminar(), encapsulando todo el código SQL necesario para estas operaciones. Esta abstracción permite que el resto de la aplicación trabaje con objetos Java sin preocuparse por los detalles de la persistencia.

La implementación de DAO utiliza JDBC (Java Database Connectivity) para establecer conexiones con la base de datos, preparar consultas SQL, ejecutarlas y mapear los resultados a objetos del modelo. El manejo adecuado de conexiones, transacciones y excepciones es fundamental para garantizar la integridad y consistencia de los datos \cite{bauer2015}.

\subsection{Servlets y JSP}

Los Servlets son componentes Java del lado del servidor que extienden las capacidades de los servidores web, procesando peticiones y generando respuestas dinámicamente \cite{hall2011}. Un Servlet es una clase Java que implementa la interfaz javax.servlet.Servlet, generalmente extendiendo HttpServlet para manejar peticiones HTTP. Los métodos doGet() y doPost() procesan peticiones GET y POST respectivamente, permitiendo implementar la lógica de control de la aplicación.

Las JSP (JavaServer Pages) son una tecnología que simplifica la creación de contenido web dinámico, permitiendo mezclar HTML estático con código Java. Las páginas JSP se compilan automáticamente en Servlets la primera vez que son solicitadas, combinando la simplicidad de HTML con el poder de Java. Esta tecnología facilita la creación de interfaces de usuario dinámicas sin necesidad de generar todo el HTML mediante código Java.

La combinación de Servlets y JSP implementa naturalmente el patrón MVC: los Servlets actúan como controladores procesando la lógica de negocio, mientras que las JSP sirven como vistas presentando la información. Esta arquitectura permite desarrollo ágil, mantenimiento simplificado y separación clara de responsabilidades entre diseñadores (JSP) y programadores (Servlets).

\section{Análisis y Diseño}

\subsection{Diagrama de Clases del Modelo}

El diagrama de clases del modelo representa la estructura fundamental del sistema, mostrando las entidades principales del dominio, sus atributos, métodos y las relaciones entre ellas. Este diagrama constituye el núcleo de la aplicación, ya que en estas clases se aplican directamente los conceptos de herencia, polimorfismo, encapsulamiento y abstracción estudiados en el curso.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/diagramUML.png}
\caption{Diagrama de clases del modelo del sistema}
\label{fig:diagrama-clases}
\end{figure}

El diagrama presenta las clases principales que modelan el dominio del negocio:

\begin{itemize}
    \item \textbf{Usuario (abstracta)}: Clase base que define la estructura común para todos los tipos de usuarios
    \item \textbf{Administrador, Cajero, Cliente}: Clases especializadas que heredan de Usuario
    \item \textbf{Producto}: Representa los artículos disponibles en el cafetín
    \item \textbf{Pedido}: Modela las órdenes realizadas por los clientes
    \item \textbf{DetallePedido}: Representa cada línea de un pedido con su producto y cantidad
\end{itemize}

Este diseño permite una clara separación de responsabilidades y facilita la extensibilidad del sistema, ya que agregar nuevos tipos de usuarios o entidades solo requiere crear nuevas clases que sigan la estructura establecida.

\subsection{Explicación de las Relaciones entre Clases}

Las relaciones entre clases definen cómo los objetos del sistema interactúan y se conectan entre sí. Cada tipo de relación tiene implicaciones específicas en la implementación y el comportamiento del sistema.

\subsubsection{Herencia en la jerarquía de Usuario}

La clase abstracta \texttt{Usuario} define la estructura y comportamiento común para todos los tipos de usuarios del sistema. Las clases \texttt{Administrador}, \texttt{Cajero} y \texttt{Cliente} heredan de \texttt{Usuario}, especializando su funcionalidad según el rol específico. Esta relación de herencia permite aplicar \textbf{polimorfismo}, donde un método puede trabajar con cualquier tipo de Usuario sin conocer su tipo específico, simplemente invocando los métodos abstractos que cada subclase implementa de forma particular.

La decisión de hacer \texttt{Usuario} abstracta se justifica porque no tiene sentido crear instancias de un ``Usuario'' genérico; todo usuario del sistema debe tener un rol específico (administrador, cajero o cliente). Los métodos abstractos como \texttt{mostrarInfo()}, \texttt{calcularAcceso()} y \texttt{getRol()} obligan a cada subclase a proporcionar su propia implementación, garantizando que cada tipo de usuario tenga comportamiento específico para estas operaciones.

Esta jerarquía ejemplifica el principio de \textbf{abstracción}, donde se identifican las características esenciales comunes (nombre, email, password, fechaRegistro) y se definen en la clase base, mientras que las características específicas de cada rol se implementan en las subclases correspondientes.

\subsubsection{Asociación entre Cliente y Pedido}

Un \texttt{Cliente} puede realizar múltiples \texttt{Pedidos} a lo largo del tiempo, estableciendo una relación \textbf{uno-a-muchos} (1..*). Esta asociación se implementa mediante el atributo \texttt{idUsuario} en la clase \texttt{Pedido}, que funciona como clave foránea referenciando al cliente que realizó el pedido.

La relación es \textbf{unidireccional} desde \texttt{Pedido} hacia \texttt{Cliente}, ya que los pedidos necesitan saber quién los realizó para propósitos de registro y seguimiento, pero un cliente no mantiene una lista de todos sus pedidos en memoria (esta información se consulta desde la base de datos cuando es necesario). Esta decisión de diseño optimiza el uso de memoria y evita inconsistencias entre objetos en memoria y datos persistidos.

\subsubsection{Composición entre Pedido y DetallePedido}

Un \texttt{Pedido} se compone de múltiples \texttt{DetallePedido}, donde cada detalle representa un producto específico con su cantidad y precio unitario. Esta es una relación de \textbf{composición fuerte}, representada en UML con un rombo relleno, porque:

\begin{enumerate}
    \item Los detalles no pueden existir sin un pedido padre
    \item Si se elimina un pedido, todos sus detalles también deben eliminarse
    \item El ciclo de vida de los detalles está completamente controlado por el pedido
\end{enumerate}

La clase \texttt{Pedido} mantiene una lista (\texttt{List<DetallePedido>}) de todos sus detalles, permitiendo gestionar todos los productos del pedido como una unidad cohesiva. Esta relación también facilita el cálculo automático del total del pedido sumando los subtotales de cada detalle.

\subsubsection{Asociación entre DetallePedido y Producto}

Cada \texttt{DetallePedido} referencia al \texttt{Producto} que se está ordenando mediante el atributo \texttt{idProducto}. Esta es una \textbf{asociación simple} (no composición ni agregación), ya que:

\begin{itemize}
    \item El detalle necesita conocer el producto para obtener su información (nombre, precio)
    \item El detalle no posee ni controla el ciclo de vida del producto
    \item Los productos existen independientemente de los pedidos que los referencian
\end{itemize}

Una característica importante de esta relación es que cuando se crea un detalle de pedido, se captura y almacena el \texttt{precioUnitario} del producto en ese momento específico. Esto garantiza que cambios futuros en el precio del producto no afecten pedidos históricos, manteniendo la integridad de los registros comerciales.

\subsection{Modelo de Base de Datos}

El modelo de base de datos representa el esquema relacional que persiste la información del sistema. Este diseño implementa las entidades del modelo orientado a objetos mediante tablas relacionales, aplicando principios de normalización para garantizar la integridad y eficiencia de los datos.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{img/diagramaBD.png}
\caption{Diagrama entidad-relación de la base de datos}
\label{fig:diagrama-bd}
\end{figure}

\subsubsection{Descripción de las Tablas Principales}

\paragraph{Tabla USUARIOS}
Almacena la información de todos los usuarios del sistema, implementando una estrategia de \textbf{tabla única para jerarquía de herencia} (Single Table Inheritance). Esta tabla contiene:

\begin{itemize}
    \item Atributos comunes: \texttt{id\_usuario}, \texttt{nombre}, \texttt{apellido}, \texttt{email}, \texttt{password}, \texttt{rol}, \texttt{fecha\_registro}, \texttt{activo}
    \item Atributos específicos de Administrador: \texttt{area\_gestion}, \texttt{nivel\_acceso}
    \item Atributos específicos de Cliente: \texttt{puntos\_acumulados}, \texttt{tipo\_membresia}, \texttt{saldo}
    \item Atributos específicos de Cajero: \texttt{turno}, \texttt{ventas\_diarias}
\end{itemize}

El campo \texttt{rol} actúa como discriminador para identificar el tipo específico de usuario. Los atributos no aplicables a un rol se mantienen como NULL. Esta estrategia simplifica las consultas y evita múltiples JOINs, aunque sacrifica algo de normalización.

\paragraph{Tabla PRODUCTOS}
Contiene el catálogo de productos disponibles en el cafetín. Incluye información descriptiva (\texttt{nombre}, \texttt{descripcion}), comercial (\texttt{precio}, \texttt{categoria}), y de disponibilidad (\texttt{stock}, \texttt{disponible}). Los campos \texttt{fecha\_creacion} y \texttt{fecha\_actualizacion} permiten auditoría de cambios.

\paragraph{Tabla PEDIDOS}
Registra las órdenes realizadas por los clientes. Cada pedido está vinculado a un usuario mediante \texttt{id\_usuario} (clave foránea), contiene información temporal (\texttt{fecha\_pedido}), financiera (\texttt{total}, \texttt{metodo\_pago}), y de seguimiento (\texttt{estado}, \texttt{observaciones}).

\paragraph{Tabla DETALLE\_PEDIDOS}
Implementa la relación muchos-a-muchos entre PEDIDOS y PRODUCTOS, almacenando los productos específicos de cada pedido. Cada registro contiene \texttt{cantidad}, \texttt{precio\_unitario} (capturado en el momento de la orden), y \texttt{subtotal} calculado. Esta tabla es esencial para mantener el histórico exacto de las transacciones.

\paragraph{Tabla INVENTARIO}
Gestiona los niveles de stock de cada producto, estableciendo umbrales mínimos y máximos (\texttt{cantidad\_minima}, \texttt{cantidad\_maxima}) para alertas de reabastecimiento. La relación uno-a-uno con PRODUCTOS se implementa mediante una clave foránea única (\texttt{id\_producto}).

\paragraph{Tabla MOVIMIENTOS\_INVENTARIO}
Registra todos los cambios en el inventario para auditoría y trazabilidad. Cada movimiento especifica el \texttt{tipo\_movimiento} (entrada, salida, ajuste), la \texttt{cantidad} afectada, el \texttt{motivo}, y opcionalmente el usuario responsable. Esta tabla es crucial para el control de inventario y detección de discrepancias.

\paragraph{Tabla REPORTES}
Almacena reportes generados por los administradores, incluyendo el \texttt{tipo\_reporte}, \texttt{fecha\_generacion}, y el \texttt{contenido} serializado. Esta tabla permite mantener un historial de análisis y facilita la generación de reportes recurrentes.

\subsubsection{Relaciones e Integridad Referencial}

El esquema implementa las siguientes relaciones mediante claves foráneas:

\begin{itemize}
    \item \textbf{USUARIOS $\rightarrow$ PEDIDOS}: Un usuario puede realizar múltiples pedidos (1:N)
    \item \textbf{PEDIDOS $\rightarrow$ DETALLE\_PEDIDOS}: Un pedido contiene múltiples detalles (1:N) con \texttt{ON DELETE CASCADE}
    \item \textbf{PRODUCTOS $\rightarrow$ DETALLE\_PEDIDOS}: Un producto puede aparecer en múltiples detalles (1:N)
    \item \textbf{PRODUCTOS $\rightarrow$ INVENTARIO}: Relación uno-a-uno estricta mediante clave foránea única
    \item \textbf{PRODUCTOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Trazabilidad de cambios (1:N)
    \item \textbf{USUARIOS $\rightarrow$ MOVIMIENTOS\_INVENTARIO}: Auditoría de responsables (1:N, nullable)
    \item \textbf{USUARIOS $\rightarrow$ REPORTES}: Trazabilidad de generación (1:N, nullable)
\end{itemize}

Las restricciones \texttt{ON DELETE CASCADE} en DETALLE\_PEDIDOS garantizan que al eliminar un pedido, sus detalles se eliminen automáticamente, manteniendo la coherencia de los datos y reflejando la relación de composición del modelo orientado a objetos.

\subsubsection{Normalización y Optimización}

El esquema de base de datos se encuentra en \textbf{Tercera Forma Normal (3FN)}:

\begin{itemize}
    \item \textbf{1FN}: Todos los atributos contienen valores atómicos, sin grupos repetitivos
    \item \textbf{2FN}: No existen dependencias parciales; todos los atributos no clave dependen completamente de la clave primaria
    \item \textbf{3FN}: No existen dependencias transitivas; los atributos no clave no dependen de otros atributos no clave
\end{itemize}

Se han definido índices sobre las columnas más consultadas (\texttt{email} en USUARIOS, \texttt{id\_producto} en INVENTARIO) para optimizar el rendimiento de las búsquedas frecuentes.

\\subsection{Arquitectura del Sistema: Patrón MVC}

El sistema implementa el patrón de arquitectura Modelo-Vista-Controlador (MVC), que organiza la aplicación en tres capas independientes e interconectadas. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y permite que diferentes componentes evolucionen de forma independiente sin afectar al resto del sistema.

\subsubsection{Diseño Conceptual de la Arquitectura}

La arquitectura MVC se implementa mediante cuatro capas principales que se comunican siguiendo un flujo unidireccional:

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/arquitectura-mvc.png}
\caption{Arquitectura MVC del Sistema de Gestión de Cafetín}
\label{fig:arquitectura-mvc}
\end{figure}

\begin{itemize}
    \item \textbf{Capa de Presentación (Vista):} Responsable de la interfaz de usuario y presentación de datos. Recibe las peticiones del usuario y muestra los resultados.
    
    \item \textbf{Capa de Control (Controlador):} Actúa como intermediario entre la vista y el modelo. Procesa las peticiones del usuario, invoca la lógica de negocio y decide qué vista mostrar.
    
    \item \textbf{Capa de Modelo (Lógica de Negocio):} Contiene las reglas de negocio y la lógica de la aplicación. Incluye las entidades del dominio y sus comportamientos.
    
    \item \textbf{Capa de Persistencia (Base de Datos):} Almacena y recupera los datos de la aplicación en una base de datos relacional.
\end{itemize}

\subsubsection{Flujo de Comunicación entre Capas}

El flujo de una operación típica sigue estos pasos:

\begin{enumerate}
    \item El usuario interactúa con la \textbf{Vista} (página web)
    \item La Vista envía una petición HTTP al \textbf{Controlador}
    \item El Controlador procesa la petición y llama a los métodos apropiados del \textbf{Modelo}
    \item El Modelo ejecuta la lógica de negocio y accede a la \textbf{Base de Datos} si es necesario
    \item El Modelo retorna los resultados al Controlador
    \item El Controlador selecciona la Vista apropiada y le pasa los datos
    \item La Vista presenta los resultados al usuario
\end{enumerate}

\subsubsection{Decisiones de Diseño}

Se tomaron las siguientes decisiones clave en el diseño:

\begin{itemize}
    \item \textbf{Separación estricta de responsabilidades:} Cada capa tiene responsabilidades claramente definidas y no puede acceder directamente a capas no adyacentes.
    
    \item \textbf{Uso de patrones de diseño:} Se aplicaron los patrones Singleton (para conexiones a BD), DAO (para acceso a datos), y Factory (para creación de objetos).
    
    \item \textbf{Jerarquía de usuarios mediante herencia:} Se diseñó una clase abstracta Usuario como base para Administrador, Cajero y Cliente, permitiendo polimorfismo.
    
    \item \textbf{Composición para relaciones fuertes:} La relación Pedido-DetallePedido se diseñó como composición, reflejando que los detalles no existen sin el pedido.
    
    \item \textbf{Normalización de base de datos:} El esquema de BD sigue la tercera forma normal para evitar redundancias.
\end{itemize}

\subsubsection{Componentes por Capa}

\begin{table}[H]
\centering
\caption{Componentes por capa en la arquitectura MVC}
\label{tab:componentes-capa}
\begin{tabular}{|p{3cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Capa} & \textbf{Responsabilidades} & \textbf{Tecnologías/Patrones} \\
\hline
\hline
Presentación (Vista) & Interfaz de usuario, formularios, presentación de datos & JSP, HTML, CSS, JavaScript \\
\hline
Control (Controlador) & Enrutamiento, validación, gestión de sesiones, seguridad & Servlets, Filtros, Listeners \\
\hline
Modelo (Lógica) & Reglas de negocio, entidades, validaciones & Clases Java, POO, Patrones DAO \\
\hline
Persistencia (BD) & Almacenamiento, recuperación, integridad de datos & MySQL, JDBC, SQL \\
\hline
\end{tabular}
\end{table}

\section{Implementación}

\subsection{Arquitectura Implementada}

A continuación se muestran las implementaciones concretas de cada capa del sistema:

\subsubsection{Capa de Presentación - Vistas JSP}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-vista.png}
\caption{Implementación de la capa de presentación con páginas JSP}
\label{fig:impl-vista}
\end{figure}

La capa de presentación se implementó mediante 12 páginas JSP organizadas en tres módulos: autenticación, cliente y administración. Cada página sigue una plantilla común con cabecera, menú y pie de página para mantener consistencia visual.

\subsubsection{Capa de Control - Servlets}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-control.png}
\caption{Implementación de la capa de control con Servlets}
\label{fig:impl-control}
\end{figure}

Se implementaron 4 Servlets principales que manejan las diferentes funcionalidades del sistema. Cada Servlet sigue el patrón: recibir parámetros → validar → procesar → redirigir.

\subsubsection{Capa de Modelo - Clases y DAOs}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-modelo.png}
\caption{Implementación de la capa de modelo con clases Java y DAOs}
\label{fig:impl-modelo}
\end{figure}

El modelo se implementó mediante 8 clases principales y 4 DAOs. La jerarquía de Usuario demuestra la aplicación práctica de herencia y polimorfismo.

\subsubsection{Capa de Persistencia - Base de Datos}

\begin{figure}[H]
\centering
\includegraphics[width=1.0\textwidth]{img/capa-persistencia.png}
\caption{Implementación de la capa de persistencia con MySQL}
\label{fig:impl-persistencia}
\end{figure}

La base de datos se implementó con 4 tablas principales relacionadas mediante claves foráneas, siguiendo principios de normalización.


\subsection{Clases del Modelo}

\subsubsection{Usuario.java - Clase abstracta base}

\begin{javacode}{Usuario.java - Clase abstracta base}
package com.cafeteria.modelo;
import java.sql.Timestamp;

public abstract class Usuario {
    protected int idUsuario;
    protected String nombre;
    protected String apellido;
    protected String email;
    protected String password;
    protected Timestamp fechaRegistro;
    protected boolean activo;

    public Usuario(String nombre, String apellido, String email, String password) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.email = email;
        this.password = password;
        this.activo = true;
    }

    public Usuario() {
    }

    // Getters y Setters con encapsulamiento
    public int getIdUsuario() { 
        return idUsuario; 
    }
    
    public void setIdUsuario(int idUsuario) { 
        this.idUsuario = idUsuario; 
    }

    public String getNombre() { 
        return nombre; 
    }
    
    public void setNombre(String nombre) { 
        this.nombre = nombre; 
    }

    public String getApellido() { 
        return apellido; 
    }
    
    public void setApellido(String apellido) { 
        this.apellido = apellido; 
    }

    // Métodos abstractos para polimorfismo
    public abstract String mostrarInfo();
    public abstract String calcularAcceso();
    public abstract String getRol();

    // Métodos concretos comunes
    public String getNombreCompleto() { 
        return nombre + " " + apellido; 
    }

    public boolean validarCredenciales(String email, String password) {
        return this.email.equals(email) && 
               this.password.equals(password) && 
               this.activo;
    }

    @Override
    public String toString() {
        return "Usuario{" + 
               "id=" + idUsuario + 
               ", nombre=" + getNombreCompleto() + 
               ", email=" + email + 
               ", rol=" + getRol() + 
               '}';
    }
}
\end{javacode}

\subsubsection{Cliente.java - Implementación concreta con herencia}

\begin{javacode}{Cliente.java - Implementación concreta}
package com.cafeteria.modelo;

public class Cliente extends Usuario {
    private int puntosAcumulados;
    private String tipoMembresia;
    private double saldo;

    public Cliente(String nombre, String apellido, String email, String password) {
        super(nombre, apellido, email, password);
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }

    public Cliente() {
        super();
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }

    // Getters y Setters
    public int getPuntosAcumulados() {
        return puntosAcumulados;
    }

    public void setPuntosAcumulados(int puntosAcumulados) {
        this.puntosAcumulados = puntosAcumulados;
        actualizarMembresia();
    }

    public String getTipoMembresia() {
        return tipoMembresia;
    }

    public void setTipoMembresia(String tipoMembresia) {
        this.tipoMembresia = tipoMembresia;
    }

    public double getSaldo() {
        return saldo;
    }

    public void setSaldo(double saldo) {
        this.saldo = saldo;
    }

    // Implementación de métodos abstractos (POLIMORFISMO)
    @Override
    public String mostrarInfo() {
        return String.format("CLIENTE\n" +
                           "Nombre: %s\n" +
                           "Email: %s\n" +
                           "Membresía: %s\n" +
                           "Puntos: %d\n" +
                           "Saldo: S/ %.2f\n" +
                           "Estado: %s",
                           getNombreCompleto(), email, tipoMembresia, 
                           puntosAcumulados, saldo, activo ? "Activo" : "Inactivo");
    }

    @Override
    public String calcularAcceso() {
        return "Acceso CLIENTE: Menú, Carrito, Mis Pedidos, Mi Perfil";
    }

    @Override
    public String getRol() {
        return "cliente";
    }

    // Métodos específicos de Cliente
    public boolean agregarSaldo(double monto) {
        if (monto <= 0) {
            return false;
        }
        this.saldo += monto;
        return true;
    }

    public boolean tieneSaldoSuficiente(double monto) {
        return this.saldo >= monto;
    }

    public boolean realizarCompra(double totalCompra) {
        if (!tieneSaldoSuficiente(totalCompra)) {
            return false;
        }
        
        // Descontar del saldo
        this.saldo -= totalCompra;
        
        // Acumular puntos: 1 punto por cada S/5 gastados
        acumularPuntos(totalCompra);
        
        return true;
    }

    public void acumularPuntos(double totalCompra) {
        int puntosGanados = (int) (totalCompra / 5);
        this.puntosAcumulados += puntosGanados;
        actualizarMembresia();
    }

    private void actualizarMembresia() {
        if (puntosAcumulados >= 100) {
            this.tipoMembresia = "Oro";
        } else if (puntosAcumulados >= 50) {
            this.tipoMembresia = "Plata";
        } else if (puntosAcumulados >= 20) {
            this.tipoMembresia = "Bronce";
        } else {
            this.tipoMembresia = "Ninguna";
        }
    }

    public double calcularDescuento() {
        switch (tipoMembresia) {
            case "Oro":
                return 0.15; // 15%
            case "Plata":
                return 0.10; // 10%
            case "Bronce":
                return 0.05; // 5%
            case "Ninguna":
                return 0.0; // 0% para nuevos usuarios
            default:
                return 0.0;
        }
    }
}
\end{javacode}

\subsubsection{Producto.java - Encapsulamiento de datos}

\begin{javacode}{Producto.java - Encapsulamiento}
package com.cafeteria.modelo;

public class Producto {
    private int idProducto;
    private String nombre;
    private String descripcion;
    private double precio;
    private int stock;
    private String categoria;
    private boolean disponible;
    private String imagen;

    public Producto() {}

    public Producto(String nombre, String descripcion, double precio, int stock, String categoria) {
        this.nombre = nombre;
        this.descripcion = descripcion;
        this.precio = precio;
        this.stock = stock;
        this.categoria = categoria;
        this.disponible = true;
    }

    // Getters y Setters
    public int getIdProducto() { return idProducto; }
    public void setIdProducto(int idProducto) { this.idProducto = idProducto; }
    
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
    
    public String getDescripcion() { return descripcion; }
    public void setDescripcion(String descripcion) { this.descripcion = descripcion; }
    
    public double getPrecio() { return precio; }
    public void setPrecio(double precio) { this.precio = precio; }
    
    public int getStock() { return stock; }
    public void setStock(int stock) { 
        this.stock = stock;
        if (this.stock <= 0) {
            this.disponible = false;
        }
    }
    
    public String getCategoria() { return categoria; }
    public void setCategoria(String categoria) { this.categoria = categoria; }
    
    public boolean isDisponible() { return disponible; }
    public void setDisponible(boolean disponible) { this.disponible = disponible; }
    
    public String getImagen() { return imagen; }
    public void setImagen(String imagen) { this.imagen = imagen; }

    // Métodos de lógica de negocio
    public boolean hayStock() {
        return stock > 0 && disponible;
    }

    public void actualizarStock(int cantidad) {
        this.stock += cantidad;
        if (this.stock <= 0) {
            this.disponible = false;
        } else {
            this.disponible = true;
        }
    }

    public boolean verificarDisponibilidad() {
        if (!disponible || stock <= 0) {
            this.disponible = false;
            return false;
        }
        return true;
    }

    public double calcularPrecioConDescuento(double descuento) {
        if (descuento < 0 || descuento > 1) {
            return precio;
        }
        return precio * (1 - descuento);
    }

    public String obtenerEstado() {
        if (!disponible) return "No disponible";
        if (stock <= 5) return "Stock bajo";
        if (stock <= 10) return "Stock medio";
        return "Disponible";
    }

    @Override
    public String toString() {
        return String.format("Producto{id=%d, nombre='%s', precio=S/%.2f, stock=%d, estado='%s'}", 
                           idProducto, nombre, precio, stock, obtenerEstado());
    }
}
\end{javacode}

\subsubsection{Pedido.java - Composición y relaciones}

\begin{javacode}{Pedido.java - Composición}
package com.cafeteria.modelo;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;

public class Pedido {
    private int idPedido;
    private int idUsuario;
    private Timestamp fechaPedido;
    private double total;
    private String estado;
    private String metodoPago;
    private String observaciones;
    
    // COMPOSICIÓN: El pedido contiene una lista de detalles
    private List<DetallePedido> detalles;

    public Pedido() {
        this.detalles = new ArrayList<>();
        this.estado = "pendiente";
        this.total = 0.0;
    }

    public Pedido(int idUsuario, String metodoPago) {
        this.idUsuario = idUsuario;
        this.metodoPago = metodoPago;
        this.estado = "pendiente";
        this.total = 0.0;
        this.detalles = new ArrayList<>();
    }

    // Getters y Setters
    public int getIdPedido() { return idPedido; }
    public void setIdPedido(int idPedido) { this.idPedido = idPedido; }
    
    public int getIdUsuario() { return idUsuario; }
    public void setIdUsuario(int idUsuario) { this.idUsuario = idUsuario; }
    
    public Timestamp getFechaPedido() { return fechaPedido; }
    public void setFechaPedido(Timestamp fechaPedido) { this.fechaPedido = fechaPedido; }
    
    public double getTotal() { return total; }
    public void setTotal(double total) { this.total = total; }
    
    public String getEstado() { return estado; }
    public void setEstado(String estado) { this.estado = estado; }
    
    public String getMetodoPago() { return metodoPago; }
    public void setMetodoPago(String metodoPago) { this.metodoPago = metodoPago; }
    
    public String getObservaciones() { return observaciones; }
    public void setObservaciones(String observaciones) { this.observaciones = observaciones; }
    
    public List<DetallePedido> getDetalles() { return detalles; }
    public void setDetalles(List<DetallePedido> detalles) { this.detalles = detalles; }

    // Métodos para gestionar la composición
    public void agregarDetalle(DetallePedido detalle) {
        this.detalles.add(detalle);
        calcularTotal();
    }

    public void calcularTotal() {
        this.total = 0;
        for (DetallePedido detalle : detalles) {
            this.total += detalle.getSubtotal();
        }
    }

    public void cambiarEstado(String nuevoEstado) {
        String[] estadosValidos = {"pendiente", "preparando", "listo", "entregado", "cancelado"};
        for (String estadoValido : estadosValidos) {
            if (estadoValido.equals(nuevoEstado)) {
                this.estado = nuevoEstado;
                return;
            }
        }
        throw new IllegalArgumentException("Estado no válido: " + nuevoEstado);
    }

    public String generarTicket() {
        StringBuilder ticket = new StringBuilder();
        ticket.append("========================================\n");
        ticket.append("         CAFETÍN UNIVERSITARIO          \n");
        ticket.append("========================================\n");
        ticket.append(String.format("Pedido #%d\n", idPedido));
        ticket.append(String.format("Fecha: %s\n", fechaPedido));
        ticket.append(String.format("Estado: %s\n", estado.toUpperCase()));
        ticket.append("----------------------------------------\n");
        ticket.append("Productos:\n");
        
        for (DetallePedido detalle : detalles) {
            ticket.append(String.format("  %s x%d - S/%.2f\n", 
                detalle.getNombreProducto(), 
                detalle.getCantidad(), 
                detalle.getSubtotal()));
        }
        
        ticket.append("----------------------------------------\n");
        ticket.append(String.format("TOTAL: S/%.2f\n", total));
        ticket.append(String.format("Método de pago: %s\n", metodoPago));
        if (observaciones != null && !observaciones.isEmpty()) {
            ticket.append(String.format("Observaciones: %s\n", observaciones));
        }
        ticket.append("========================================\n");
        ticket.append("      ¡Gracias por su compra!          \n");
        ticket.append("========================================\n");
        
        return ticket.toString();
    }

    public boolean validarStock() {
        if (detalles == null || detalles.isEmpty()) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return String.format("Pedido{id=%d, total=S/%.2f, estado='%s', productos=%d}", 
                           idPedido, total, estado, detalles.size());
    }
}
\end{javacode}

\subsection{Patrón DAO para Persistencia}

\subsubsection{ConexionBD.java - Patrón Singleton}

\begin{javacode}{ConexionBD.java - Singleton para conexiones}
package com.cafeteria.dao;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConexionBD {
    // Datos de conexión
    private static final String URL = "jdbc:mysql://localhost:3306/cafetin";
    private static final String USUARIO = "root";
    private static final String PASSWORD = "";
    private static final String DRIVER = "com.mysql.cj.jdbc.Driver";
    
    // Instancia única (SINGLETON)
    private static Connection conexion = null;

    // Constructor privado para prevenir instanciación
    private ConexionBD() {
    }

    // Método para obtener la conexión (SINGLETON)
    public static Connection getConexion() {
        try {
            if (conexion == null || conexion.isClosed()) {
                // Cargar el driver
                Class.forName(DRIVER);
                // Establecer conexión
                conexion = DriverManager.getConnection(URL, USUARIO, PASSWORD);
                System.out.println("✅ Conexión exitosa a la base de datos");
            }
        } catch (ClassNotFoundException e) {
            System.err.println("❌ Error: Driver no encontrado");
            System.err.println("Asegúrate de tener mysql-connector-java.jar en WEB-INF/lib/");
            e.printStackTrace();
        } catch (SQLException e) {
            System.err.println("❌ Error al conectar con la base de datos");
            System.err.println("Verifica que XAMPP esté ejecutando MySQL");
            e.printStackTrace();
        }
        return conexion;
    }

    // Método para cerrar la conexión
    public static void cerrarConexion() {
        try {
            if (conexion != null && !conexion.isClosed()) {
                conexion.close();
                System.out.println("✅ Conexión cerrada correctamente");
            }
        } catch (SQLException e) {
            System.err.println("❌ Error al cerrar la conexión");
            e.printStackTrace();
        }
    }

    // Método para probar la conexión
    public static boolean probarConexion() {
        Connection conn = getConexion();
        return conn != null;
    }
}
\end{javacode}

\subsubsection{UsuarioDAO.java - Mapeo objeto-relacional con herencia}

\begin{javacode}{UsuarioDAO.java - Mapeo con herencia}
package com.cafeteria.dao;
import com.cafeteria.modelo.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class UsuarioDAO {
    // Autenticar usuario con mapeo polimórfico
    public Usuario autenticar(String email, String password) {
        Usuario usuario = null;
        String sql = "SELECT * FROM usuarios WHERE email = ? " +
                    "AND password = MD5(?) AND activo = true";
        
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, email);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                String rol = rs.getString("rol");
                
                // Creación polimórfica según el rol
                switch (rol) {
                    case "administrador":
                        Administrador admin = new Administrador();
                        admin.setIdUsuario(rs.getInt("id_usuario"));
                        admin.setNombre(rs.getString("nombre"));
                        admin.setApellido(rs.getString("apellido"));
                        admin.setEmail(rs.getString("email"));
                        admin.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        admin.setActivo(rs.getBoolean("activo"));
                        admin.setAreaGestion(rs.getString("area_gestion"));
                        admin.setNivelAcceso(rs.getInt("nivel_acceso"));
                        usuario = admin;
                        break;
                        
                    case "cliente":
                        Cliente cliente = new Cliente();
                        cliente.setIdUsuario(rs.getInt("id_usuario"));
                        cliente.setNombre(rs.getString("nombre"));
                        cliente.setApellido(rs.getString("apellido"));
                        cliente.setEmail(rs.getString("email"));
                        cliente.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        cliente.setActivo(rs.getBoolean("activo"));
                        cliente.setPuntosAcumulados(rs.getInt("puntos_acumulados"));
                        cliente.setTipoMembresia(rs.getString("tipo_membresia"));
                        cliente.setSaldo(rs.getDouble("saldo"));
                        usuario = cliente;
                        break;
                        
                    case "cajero":
                        Cajero cajero = new Cajero();
                        cajero.setIdUsuario(rs.getInt("id_usuario"));
                        cajero.setNombre(rs.getString("nombre"));
                        cajero.setApellido(rs.getString("apellido"));
                        cajero.setEmail(rs.getString("email"));
                        cajero.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        cajero.setActivo(rs.getBoolean("activo"));
                        cajero.setTurno(rs.getString("turno"));
                        cajero.setVentasDiarias(rs.getDouble("ventas_diarias"));
                        usuario = cajero;
                        break;
                }
            }
        } catch (SQLException e) {
            System.err.println("Error al autenticar usuario: " + e.getMessage());
        }
        return usuario;
    }

    // Insertar usuario con discriminación por tipo
    public boolean insertar(Usuario usuario) {
        String sql = "INSERT INTO usuarios (nombre, apellido, email, password, rol, " +
                    "area_gestion, nivel_acceso, puntos_acumulados, tipo_membresia, turno, saldo) " +
                    "VALUES (?, ?, ?, MD5(?), ?, ?, ?, ?, ?, ?, ?)";
        
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, usuario.getNombre());
            stmt.setString(2, usuario.getApellido());
            stmt.setString(3, usuario.getEmail());
            stmt.setString(4, usuario.getPassword());
            stmt.setString(5, usuario.getRol());
            
            // Configurar campos específicos según el tipo de usuario
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                stmt.setString(6, admin.getAreaGestion());
                stmt.setInt(7, admin.getNivelAcceso());
                stmt.setNull(8, Types.INTEGER);
                stmt.setNull(9, Types.VARCHAR);
                stmt.setNull(10, Types.VARCHAR);
                stmt.setNull(11, Types.DOUBLE);
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                stmt.setNull(6, Types.VARCHAR);
                stmt.setNull(7, Types.INTEGER);
                stmt.setInt(8, cliente.getPuntosAcumulados());
                stmt.setString(9, cliente.getTipoMembresia());
                stmt.setNull(10, Types.VARCHAR);
                stmt.setDouble(11, cliente.getSaldo());
            } else if (usuario instanceof Cajero) {
                Cajero cajero = (Cajero) usuario;
                stmt.setNull(6, Types.VARCHAR);
                stmt.setNull(7, Types.INTEGER);
                stmt.setNull(8, Types.INTEGER);
                stmt.setNull(9, Types.VARCHAR);
                stmt.setString(10, cajero.getTurno());
                stmt.setNull(11, Types.DOUBLE);
            }
            
            int filasAfectadas = stmt.executeUpdate();
            return filasAfectadas > 0;
        } catch (SQLException e) {
            System.err.println("Error al insertar usuario: " + e.getMessage());
            return false;
        }
    }

    // Buscar usuario por ID
    public Usuario buscarPorId(int id) {
        Usuario usuario = null;
        String sql = "SELECT * FROM usuarios WHERE id_usuario = ?";
        
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                String rol = rs.getString("rol");
                
                switch (rol) {
                    case "administrador":
                        Administrador admin = new Administrador();
                        mapearUsuarioBase(admin, rs);
                        admin.setAreaGestion(rs.getString("area_gestion"));
                        admin.setNivelAcceso(rs.getInt("nivel_acceso"));
                        usuario = admin;
                        break;
                        
                    case "cliente":
                        Cliente cliente = new Cliente();
                        mapearUsuarioBase(cliente, rs);
                        cliente.setPuntosAcumulados(rs.getInt("puntos_acumulados"));
                        cliente.setTipoMembresia(rs.getString("tipo_membresia"));
                        cliente.setSaldo(rs.getDouble("saldo"));
                        usuario = cliente;
                        break;
                        
                    case "cajero":
                        Cajero cajero = new Cajero();
                        mapearUsuarioBase(cajero, rs);
                        cajero.setTurno(rs.getString("turno"));
                        cajero.setVentasDiarias(rs.getDouble("ventas_diarias"));
                        usuario = cajero;
                        break;
                }
            }
        } catch (SQLException e) {
            System.err.println("Error al buscar usuario: " + e.getMessage());
        }
        return usuario;
    }

    // Método auxiliar para mapear atributos comunes
    private void mapearUsuarioBase(Usuario usuario, ResultSet rs) throws SQLException {
        usuario.setIdUsuario(rs.getInt("id_usuario"));
        usuario.setNombre(rs.getString("nombre"));
        usuario.setApellido(rs.getString("apellido"));
        usuario.setEmail(rs.getString("email"));
        usuario.setFechaRegistro(rs.getTimestamp("fecha_registro"));
        usuario.setActivo(rs.getBoolean("activo"));
    }
}
\end{javacode}

\subsection{Servlets como Controladores}

\subsubsection{ServletLogin.java - Controlador de autenticación}

\begin{javacode}{ServletLogin.java - Controlador de autenticación}
package com.cafeteria.controlador;
import com.cafeteria.dao.UsuarioDAO;
import com.cafeteria.modelo.*;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;

@WebServlet(name = "ServletLogin", urlPatterns = {"/ServletLogin"})
public class ServletLogin extends HttpServlet {
    private UsuarioDAO usuarioDAO = new UsuarioDAO();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        String accion = request.getParameter("accion");
        
        if ("login".equals(accion)) {
            procesarLogin(request, response);
        } else if ("registro".equals(accion)) {
            procesarRegistro(request, response);
        } else if ("logout".equals(accion)) {
            procesarLogout(request, response);
        }
    }

    private void procesarLogin(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        
        // Delegar autenticación al modelo (DAO)
        Usuario usuario = usuarioDAO.autenticar(email, password);
        
        if (usuario != null) {
            // Configurar sesión HTTP
            HttpSession session = request.getSession();
            session.setAttribute("usuario", usuario);
            session.setAttribute("idUsuario", usuario.getIdUsuario());
            session.setAttribute("nombreUsuario", usuario.getNombreCompleto());
            session.setAttribute("rol", usuario.getRol());
            
            // Configurar atributos específicos según tipo de usuario
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                session.setAttribute("areaGestion", admin.getAreaGestion());
                session.setAttribute("nivelAcceso", admin.getNivelAcceso());
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                session.setAttribute("puntosAcumulados", cliente.getPuntosAcumulados());
                session.setAttribute("tipoMembresia", cliente.getTipoMembresia());
            } else if (usuario instanceof Cajero) {
                Cajero cajero = (Cajero) usuario;
                session.setAttribute("turno", cajero.getTurno());
            }
            
            // Redirigir según rol (POLIMORFISMO en acción)
            if (usuario instanceof Administrador || usuario instanceof Cajero) {
                response.sendRedirect("dashboard.jsp");
            } else {
                response.sendRedirect("menu.jsp");
            }
        } else {
            request.setAttribute("error", "Email o contraseña incorrectos");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        }
    }

    private void procesarRegistro(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        String nombre = request.getParameter("nombre");
        String apellido = request.getParameter("apellido");
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        String confirmarPassword = request.getParameter("confirmarPassword");
        
        // Validar contraseñas
        if (!password.equals(confirmarPassword)) {
            request.setAttribute("error", "Las contraseñas no coinciden");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
            return;
        }
        
        // Crear objeto Cliente
        Cliente cliente = new Cliente(nombre, apellido, email, password);
        
        // Insertar en base de datos
        boolean registrado = usuarioDAO.insertar(cliente);
        
        if (registrado) {
            request.setAttribute("mensaje", "Registro exitoso. Ya puedes iniciar sesión.");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        } else {
            request.setAttribute("error", "Error al registrar. El email podría estar en uso.");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
        }
    }

    private void procesarLogout(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        HttpSession session = request.getSession(false);
        if (session != null) {
            session.invalidate();
        }
        response.sendRedirect("index.jsp");
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }
}
\end{javacode}

\section{Resultados y Pruebas}

\subsection{Funcionalidades Implementadas}

\begin{table}[H]
\centering
\caption{Funcionalidades Implementadas en el Sistema}
\label{tab:funcionalidades}
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\textbf{Módulo} & \textbf{Funcionalidades Logradas} \\
\hline
\hline
\textbf{Autenticación y Gestión de Usuarios} & 
\begin{itemize}[leftmargin=*,nosep]
    \item Sistema de login seguro con encriptación MD5
    \item Registro de nuevos clientes con validación
    \item Gestión de sesiones HTTP con atributos específicos por rol
    \item Implementación de jerarquía de usuarios con herencia
\end{itemize} \\
\hline
\textbf{Gestión de Productos} &
\begin{itemize}[leftmargin=*,nosep]
    \item CRUD completo de productos con persistencia en MySQL
    \item Control de stock con actualización automática
    \item Categorización y filtrado de productos
    \item Sistema de disponibilidad automática según stock
\end{itemize} \\
\hline
\textbf{Sistema de Pedidos} &
\begin{itemize}[leftmargin=*,nosep]
    \item Carrito de compras con gestión de sesiones
    \item Cálculo automático de totales y subtotales
    \item Gestión de estados del pedido (pendiente, preparando, entregado)
    \item Validación de stock en tiempo real
    \item Generación de tickets de compra
\end{itemize} \\
\hline
\textbf{Sistema de Clientes y Membresías} &
\begin{itemize}[leftmargin=*,nosep]
    \item Acumulación de puntos por compras (1 punto por cada S/5)
    \item Sistema de membresías automático (Bronce, Plata, Oro)
    \item Descuentos progresivos según nivel de membresía
    \item Gestión de saldo electrónico
\end{itemize} \\
\hline
\textbf{Arquitectura y Diseño} &
\begin{itemize}[leftmargin=*,nosep]
    \item Implementación completa del patrón MVC
    \item Aplicación de principios POO (herencia, polimorfismo, encapsulamiento)
    \item Patrón DAO para abstracción de persistencia
    \item Patrón Singleton para gestión de conexiones
    \item Base de datos normalizada en 3FN
\end{itemize} \\
\hline
\end{tabular}
\end{table}

\subsection{Interfaces de Usuario Desarrolladas}

\subsubsection{Pantalla de Login}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/login.png}
\caption{Pantalla de login del sistema con validación de credenciales}
\label{fig:login}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Formulario de login con campos email y password
    \item Validación del lado del cliente (JavaScript) y servidor
    \item Encriptación MD5 de contraseñas
    \item Manejo de errores con mensajes personalizados
    \item Redirección según tipo de usuario (polimorfismo en acción)
\end{itemize}

\subsubsection{Menú Principal}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/menu.png}
\caption{Menú principal con productos categorizados y sistema de filtrado}
\label{fig:menu}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Visualización de productos por categorías
    \item Sistema de filtrado dinámico
    \item Información detallada de cada producto (precio, stock, descripción)
    \item Botones para agregar al carrito con selección de cantidad
    \item Diseño responsive y atractivo
\end{itemize}

\subsubsection{Carrito de Compras}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{img/carrito.png}
\caption{Carrito de compras con resumen de productos, cantidades y total}
\label{fig:carrito}
\end{figure}

\textbf{Características implementadas:}
\begin{itemize}
    \item Gestión de carrito mediante sesiones HTTP
    \item Actualización dinámica de cantidades
    \item Cálculo automático de subtotales y total
    \item Aplicación automática de descuentos por membresía
    \item Validación de stock antes de confirmar compra
    \item Opciones para modificar o eliminar productos
\end{itemize}

\subsection{Resultados Técnicos Obtenidos}

\subsubsection{Aplicación Exitosa de Principios POO}

El proyecto demostró la aplicación efectiva de los principios fundamentales de Programación Orientada a Objetos:

\begin{itemize}
    \item \textbf{Herencia:} Implementada en la jerarquía Usuario → Administrador/Cajero/Cliente, permitiendo reutilización de código y especialización de comportamientos.
    
    \item \textbf{Polimorfismo:} Logrado mediante métodos abstractos en la clase Usuario que cada subclase implementa según su rol específico.
    
    \item \textbf{Encapsulamiento:} Aplicado consistentemente en todas las clases del modelo, protegiendo los atributos y exponiendo solo interfaces controladas.
    
    \item \textbf{Abstracción:} Utilizada en la definición de contratos mediante clases abstractas e interfaces.
\end{itemize}

\subsubsection{Arquitectura MVC Funcional}

Se implementó exitosamente una arquitectura Modelo-Vista-Controlador que proporciona:

\begin{itemize}
    \item \textbf{Separación clara de responsabilidades:} Cada capa tiene responsabilidades bien definidas y limitadas.
    
    \item \textbf{Mantenibilidad:} Cambios en una capa no afectan significativamente a las otras.
    
    \item \textbf{Escalabilidad:} La arquitectura permite agregar nuevas funcionalidades sin comprometer la estructura existente.
\end{itemize}

\subsubsection{Integración Exitosa de Tecnologías}

El proyecto logró integrar múltiples tecnologías de forma coherente:

\begin{itemize}
    \item \textbf{Java EE:} Para la lógica de negocio y controladores.
    
    \item \textbf{JSP:} Para la generación de vistas dinámicas.
    
    \item \textbf{MySQL:} Para el almacenamiento persistente de datos.
    
    \item \textbf{JDBC:} Para la comunicación entre Java y la base de datos.
    
    \item \textbf{HTML/CSS/JavaScript:} Para la interfaz de usuario y experiencia del cliente.
\end{itemize}

\subsubsection{Base de Datos Normalizada}

Se diseñó e implementó una base de datos relacional que cumple con:

\begin{itemize}
    \item \textbf{Tercera Forma Normal (3FN):} Eliminando redundancias y dependencias transitivas.
    
    \item \textbf{Integridad Referencial:} Implementada mediante claves foráneas y restricciones.
    
    \item \textbf{Optimización:} Índices en columnas frecuentemente consultadas para mejorar el rendimiento.
\end{itemize}

\subsection{Desafíos Superados}

Durante el desarrollo se enfrentaron y resolvieron los siguientes desafíos:

\begin{enumerate}
    \item \textbf{Mapeo objeto-relacional:} Se implementó con éxito el patrón DAO para mapear la jerarquía de herencia de Usuario a tablas relacionales.
    
    \item \textbf{Gestión de sesiones:} Se implementó un sistema robusto de manejo de sesiones HTTP con almacenamiento de estado de usuario.
    
    \item \textbf{Validación concurrente de stock:} Se desarrolló un mecanismo para evitar ventas de productos sin stock disponible.
    
    \item \textbf{Sistema de membresías dinámico:} Se implementó un algoritmo que actualiza automáticamente el nivel de membresía según puntos acumulados.
\end{enumerate}

\subsection{Pruebas Realizadas}

Se ejecutaron pruebas para validar las funcionalidades principales:

\begin{table}[H]
\centering
\caption{Resumen de Pruebas Realizadas}
\label{tab:pruebas}
\begin{tabular}{|p{5cm}|p{4cm}|p{4cm}|}
\hline
\textbf{Funcionalidad} & \textbf{Tipo de Prueba} & \textbf{Resultado} \\
\hline
\hline
Autenticación de usuarios & Prueba funcional & \textcolor{green}{✓ Exitosa} \\
\hline
Registro de clientes & Prueba de integración & \textcolor{green}{✓ Exitosa} \\
\hline
Proceso de compra completo & Prueba de flujo completo & \textcolor{green}{✓ Exitosa} \\
\hline
Gestión de productos (CRUD) & Prueba CRUD & \textcolor{green}{✓ Exitosa} \\
\hline
Cálculo de descuentos por membresía & Prueba unitaria & \textcolor{green}{✓ Exitosa} \\
\hline
Actualización de stock concurrente & Prueba concurrente & \textcolor{green}{✓ Exitosa} \\
\hline
Persistencia en base de datos & Prueba de integración & \textcolor{green}{✓ Exitosa} \\
\hline
Gestión de sesiones & Prueba de estado & \textcolor{green}{✓ Exitosa} \\
\hline
\end{tabular}
\end{table}

\section{Conclusiones}

El desarrollo del Sistema de Gestión de Cafetín Universitario ha permitido aplicar de manera práctica los conceptos fundamentales de la Programación Orientada a Objetos en un contexto real de desarrollo de software. La implementación exitosa del sistema demuestra la efectividad de los principios POO como herramientas para crear aplicaciones modulares, mantenibles y escalables.

La herencia y el polimorfismo se evidenciaron claramente en la jerarquía de usuarios, donde la clase abstracta Usuario proporcionó una base común para las especializaciones Administrador, Cajero y Cliente. Este diseño permitió tratar a todos los tipos de usuarios de manera uniforme cuando se requería, mientras se aprovechaban sus comportamientos específicos cuando era necesario.

El encapsulamiento se aplicó consistentemente en todas las clases del modelo, protegiendo los atributos mediante modificadores de acceso privados y exponiendo únicamente métodos públicos para interactuar con los objetos. Esta práctica contribuyó significativamente a la robustez del sistema y facilitó la detección y corrección de errores.

La integración de tecnologías web (Servlets y JSP) con la base de datos MySQL a través del patrón DAO demostró la importancia de separar responsabilidades en capas bien definidas. La arquitectura MVC implementada permitió un desarrollo organizado y colaborativo, donde cambios en la interfaz de usuario no afectaron la lógica de negocio y viceversa.

El sistema desarrollado no solo cumple con los requisitos funcionales especificados, sino que también incorpora características avanzadas como sistema de membresías, control de inventario inteligente y gestión de múltiples roles de usuario. Estas funcionalidades adicionales enriquecen la experiencia del usuario final y proporcionan herramientas valiosas para la administración del cafetín.

En conclusión, el proyecto representa una aplicación completa de los principios de POO en un sistema real, demostrando cómo los conceptos teóricos se traducen en soluciones prácticas y funcionales. El conocimiento adquirido durante este desarrollo será fundamental para enfrentar desafíos más complejos en futuros proyectos de software.

\section{Referencias}

\begin{thebibliography}{99}
\bibitem{booch2007} Booch, G., Maksimchuk, R. A., Engle, M. W., Young, B. J., Conallen, J., \& Houston, K. A. (2007). \emph{Object-Oriented Analysis and Design with Applications}. Addison-Wesley Professional.

\bibitem{bloch2018} Bloch, J. (2018). \emph{Effective Java}. Addison-Wesley Professional.

\bibitem{martin2008} Martin, R. C. (2008). \emph{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.

\bibitem{gamma1994} Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \emph{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.

\bibitem{walls2015} Walls, C. (2015). \emph{Spring in Action}. Manning Publications.

\bibitem{alur2003} Alur, D., Malks, D., \& Crupi, J. (2003). \emph{Core J2EE Patterns: Best Practices and Design Strategies}. Prentice Hall.

\bibitem{bauer2015} Bauer, C., \& King, G. (2015). \emph{Java Persistence with Hibernate}. Manning Publications.

\bibitem{hall2011} Hall, M. (2011). \emph{Core Servlets and JavaServer Pages}. Prentice Hall.

\bibitem{oracle2020} Oracle Corporation. (2020). \emph{Java EE 8 Tutorial}. Oracle Press.

\bibitem{dubois2013} Dubois, P. (2013). \emph{MySQL Cookbook}. O'Reilly Media.

\bibitem{schwartz2012} Schwartz, B., Zaitsev, P., \& Tkachenko, V. (2012). \emph{High Performance MySQL}. O'Reilly Media.

\bibitem{larman2004} Larman, C. (2004). \emph{Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development}. Prentice Hall.

\bibitem{fowler2003} Fowler, M. (2003). \emph{UML Distilled: A Brief Guide to the Standard Object Modeling Language}. Addison-Wesley Professional.
\end{thebibliography}

\end{document}


% !TeX program = pdflatex --shell-escape
% !TeX TXS-program:pdflatex --shell-escape

\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{pdflscape}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{minted}
\usepackage{minted}
\usepackage{tikz}

\geometry{left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm}

\definecolor{codebackground}{RGB}{245,245,245}
\definecolor{codekeyword}{RGB}{127,0,85}
\definecolor{codestring}{RGB}{42,0,255}
\definecolor{codecomment}{RGB}{63,127,95}

\tcbuselibrary{listings,skins,breakable}

\newtcblisting{javacode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=java,
    minted options={
        numbers=left,
        numbersep=5pt,
        fontsize=\footnotesize, % Cambiado de \small a \footnotesize
        breaklines=true,
        linenos=true,
        baselinestretch=0.9, % REDUCIDO de 1.0 a 0.8
        tabsize=4,
        frame=lines,
        framesep=2mm
    },
    colback=codebackground,
    colframe=black!70,
    listing only,
    left=5mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries,
    breakable,
    #1
}

\newtcblisting{sqlcode}[2][]{
    listing engine=minted,
    minted style=vs,
    minted language=sql,
    minted options={
        numbers=left,
        numbersep=5pt,
        fontsize=\footnotesize,
        breaklines=true,
        linenos=true,
        baselinestretch=0.9,
        tabsize=4,
        frame=lines,
        framesep=2mm
    },
    colback=codebackground,
    colframe=black!70,
    listing only,
    left=5mm,
    enhanced,
    title=\textbf{#2},
    fonttitle=\bfseries,
    breakable,
    #1
}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=black
}

\newcommand{\coursename}{Escuela Profesional de Ingeniería de Sistemas e Informática}
\newcommand{\reportname}{Producto Final de la Segunda Unidad}
\newcommand{\reporttitle}{Sistema de Gestión de Cafetín Universitario}
\newcommand{\studentname}{Angiely Nina Choque}
\newcommand{\teachername}{Honorio Apaza Alanoca}
\newcommand{\subjectname}{Programación Orientada a Objetos II}

\pagestyle{fancy}
\fancyhf{}
\fancyfoot[R]{Pág. \thepage}
\rhead{Universidad Nacional de Moquegua\\\coursename}

\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\centering
\textsc{\Large \textbf{UNIVERSIDAD NACIONAL DE MOQUEGUA}}\\[0.5cm]
\textsc{\Large Facultad de Ingeniería y Arquitectura }\\[0.5cm]
\textsc{\large Escuela Profesional de Ingeniería de Sistemas e Informática}\\[0.7cm]
\includegraphics[scale=.28]{img/logo.png}\\[0.2cm] 
{ 
\Large{\bfseries{\reporttitle}}\\[0.5cm]
\large{\bfseries{\reportname}}
}\\[1.0cm]
\emph{\large Estudiante:}\\[0cm]
\studentname\\[0.7cm]
\emph{\large Docente:}\\[0cm]
\teachername\\[0.7cm]
\emph{\large Curso:}\\[0cm]
\subjectname\\[1.0cm]
{\large \today}\\[1.5cm]
\vfill
\end{titlepage}

\setstretch{1.5}
\setlength{\parindent}{1.27cm}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación y contexto}

El presente proyecto representa el producto final de la segunda unidad de Programación Orientada a Objetos II, donde se integran los conocimientos fundamentales de POO con tecnologías web y bases de datos relacionales. La motivación principal consiste en desarrollar un sistema completo de gestión para un cafetín universitario que simule un entorno real de negocio, permitiendo la consolidación de conceptos teóricos mediante su implementación práctica en una aplicación web funcional.

Este sistema aborda una problemática común en instituciones educativas: la gestión eficiente de pedidos, inventario y usuarios en establecimientos de comida. A diferencia del prototipo inicial que trabajaba únicamente con clases en memoria, esta versión incorpora persistencia de datos mediante MySQL, arquitectura MVC (Modelo-Vista-Controlador), y una interfaz web desarrollada con JSP y Servlets. El resultado es una aplicación empresarial escalable que demuestra la aplicación práctica de patrones de diseño y buenas prácticas de desarrollo.

El sistema ``Sistema de Gestión de Cafetín Universitario'' permite gestionar tres tipos de usuarios diferenciados mediante herencia: administradores con acceso completo al sistema, cajeros que procesan pedidos, y clientes que realizan compras con un sistema de membresías y puntos de fidelización. Esta diferenciación de roles ejemplifica el uso del polimorfismo y la abstracción en un contexto real, donde cada tipo de usuario tiene comportamientos y permisos específicos.

\section{Marco Teórico}

\subsection{Programación Orientada a Objetos (POO)}

La Programación Orientada a Objetos es un paradigma de programación que organiza el diseño del software en torno a objetos que contienen tanto datos como comportamientos. Este paradigma se fundamenta en cuatro principios esenciales que permiten crear sistemas modulares, reutilizables y mantenibles \cite{booch2007}. A diferencia de la programación procedural, la POO permite modelar entidades del mundo real de manera más natural y expresiva.

El \textbf{encapsulamiento} consiste en ocultar los detalles internos de implementación de un objeto, exponiendo únicamente una interfaz pública para interactuar con él. En Java, esto se logra mediante modificadores de acceso (private, protected, public) que controlan la visibilidad de atributos y métodos. Este principio mejora la seguridad del código y facilita su mantenimiento, ya que los cambios internos no afectan al código que utiliza la clase.

La \textbf{herencia} es un mecanismo que permite crear nuevas clases basándose en clases existentes, heredando sus atributos y métodos. Esto promueve la reutilización de código y establece relaciones jerárquicas entre clases. En el sistema desarrollado, la clase abstracta Usuario sirve como clase base para Administrador, Cajero y Cliente, compartiendo funcionalidad común mientras permite especializaciones específicas \cite{bloch2018}.

El \textbf{polimorfismo} permite que objetos de diferentes clases respondan al mismo mensaje de manera particular según su tipo. En Java, esto se manifiesta mediante la sobrecarga de métodos (mismo nombre, diferentes parámetros) y la redefinición de métodos heredados. Este principio permite escribir código más flexible y extensible, como se evidencia en los métodos abstractos de la clase Usuario que cada subclase implementa de forma específica.

La \textbf{abstracción} es el proceso de identificar las características esenciales de un objeto, ignorando los detalles irrelevantes para el contexto. Las clases abstractas e interfaces en Java permiten definir contratos de comportamiento sin especificar la implementación, logrando un alto nivel de modularidad y bajo acoplamiento entre componentes \cite{martin2008}.

\subsection{Patrón de Arquitectura MVC}

El patrón Modelo-Vista-Controlador (MVC) es una arquitectura de software que separa la lógica de negocio, la presentación y el control de flujo en tres componentes distintos e interconectados \cite{gamma1994}. Esta separación de responsabilidades facilita el mantenimiento, la escalabilidad y el trabajo en equipo, ya que diferentes desarrolladores pueden trabajar en cada capa de forma independiente.

El \textbf{Modelo} representa la lógica de negocio y los datos de la aplicación. Contiene las clases que modelan las entidades del dominio (Usuario, Producto, Pedido) y encapsula las reglas de negocio. En el sistema desarrollado, las clases del paquete modelo implementan la estructura de datos y los métodos que operan sobre ellos, independientemente de cómo se presentan o controlan.

La \textbf{Vista} es responsable de la presentación de la información al usuario. En aplicaciones web Java, las vistas se implementan mediante JSP (JavaServer Pages), que combinan HTML con código Java para generar páginas dinámicas. Las vistas acceden al modelo únicamente para lectura, nunca para modificación directa, manteniendo la separación de responsabilidades.

El \textbf{Controlador} actúa como intermediario entre el modelo y la vista, procesando las peticiones del usuario, invocando la lógica de negocio apropiada, y seleccionando la vista adecuada para mostrar los resultados. En Java EE, los Servlets funcionan como controladores, recibiendo peticiones HTTP, interactuando con el modelo, y redirigiendo a las vistas JSP correspondientes \cite{walls2015}.

\subsection{Patrón DAO (Data Access Object)}

El patrón DAO proporciona una interfaz abstracta para acceder a datos de cualquier fuente, típicamente una base de datos relacional. Este patrón encapsula toda la lógica de acceso a datos, separándola completamente de la lógica de negocio \cite{alur2003}. Los beneficios principales incluyen la centralización del acceso a datos, facilidad para cambiar de tecnología de persistencia, y simplificación de las pruebas unitarias mediante la posibilidad de crear implementaciones simuladas.

Un DAO típico define operaciones CRUD (Create, Read, Update, Delete) para una entidad específica del dominio. Por ejemplo, UsuarioDAO proporciona métodos como insertar(), buscarPorId(), listarTodos(), actualizar() y eliminar(), encapsulando todo el código SQL necesario para estas operaciones. Esta abstracción permite que el resto de la aplicación trabaje con objetos Java sin preocuparse por los detalles de la persistencia.

La implementación de DAO utiliza JDBC (Java Database Connectivity) para establecer conexiones con la base de datos, preparar consultas SQL, ejecutarlas y mapear los resultados a objetos del modelo. El manejo adecuado de conexiones, transacciones y excepciones es fundamental para garantizar la integridad y consistencia de los datos \cite{bauer2015}.

\subsection{Servlets y JSP}

Los Servlets son componentes Java del lado del servidor que extienden las capacidades de los servidores web, procesando peticiones y generando respuestas dinámicamente \cite{hall2011}. Un Servlet es una clase Java que implementa la interfaz javax.servlet.Servlet, generalmente extendiendo HttpServlet para manejar peticiones HTTP. Los métodos doGet() y doPost() procesan peticiones GET y POST respectivamente, permitiendo implementar la lógica de control de la aplicación.

Las JSP (JavaServer Pages) son una tecnología que simplifica la creación de contenido web dinámico, permitiendo mezclar HTML estático con código Java. Las páginas JSP se compilan automáticamente en Servlets la primera vez que son solicitadas, combinando la simplicidad de HTML con el poder de Java. Esta tecnología facilita la creación de interfaces de usuario dinámicas sin necesidad de generar todo el HTML mediante código Java.

La combinación de Servlets y JSP implementa naturalmente el patrón MVC: los Servlets actúan como controladores procesando la lógica de negocio, mientras que las JSP sirven como vistas presentando la información. Esta arquitectura permite desarrollo ágil, mantenimiento simplificado y separación clara de responsabilidades entre diseñadores (JSP) y programadores (Servlets) \cite{oracle2020}.

\subsection{MySQL y Bases de Datos Relacionales}

MySQL es un sistema de gestión de bases de datos relacionales (RDBMS) de código abierto ampliamente utilizado en aplicaciones web. Una base de datos relacional organiza la información en tablas relacionadas entre sí mediante claves primarias y foráneas, garantizando la integridad referencial y consistencia de los datos \cite{dubois2013}.

El modelo relacional se basa en la teoría de conjuntos y álgebra relacional, permitiendo realizar consultas complejas mediante SQL (Structured Query Language). Las operaciones básicas incluyen SELECT para consultas, INSERT para inserciones, UPDATE para actualizaciones y DELETE para eliminaciones. MySQL soporta características avanzadas como transacciones ACID, procedimientos almacenados, triggers, y vistas, que permiten implementar lógica compleja directamente en la base de datos \cite{schwartz2012}.

La normalización de bases de datos es un proceso mediante el cual se organizan las tablas para minimizar la redundancia y dependencias. Las formas normales (1FN, 2FN, 3FN) establecen reglas progresivamente más estrictas para el diseño de esquemas, mejorando la integridad y eficiencia de las consultas. El diseño adecuado de índices también es crucial para optimizar el rendimiento de las consultas frecuentes.

\subsection{Relaciones entre Clases en POO}

Las relaciones entre clases definen cómo los objetos interactúan y se conectan entre sí en un sistema orientado a objetos \cite{larman2004}. Existen varios tipos de relaciones, cada una con semántica y consecuencias diferentes en el diseño del sistema.

La \textbf{asociación} es la relación más general, indicando que dos clases están conectadas de alguna manera. Puede ser unidireccional (una clase conoce a la otra) o bidireccional (ambas se conocen mutuamente). Las asociaciones tienen multiplicidad, indicando cuántos objetos de cada clase participan en la relación (uno-a-uno, uno-a-muchos, muchos-a-muchos).

La \textbf{agregación} es un tipo especial de asociación que representa una relación ``todo-parte'' donde las partes pueden existir independientemente del todo. Por ejemplo, un Departamento contiene Empleados, pero los empleados pueden existir aunque se elimine el departamento. Esta relación implica una conexión débil entre los objetos participantes.

La \textbf{composición} es una forma fuerte de agregación donde las partes dependen completamente del todo para su existencia. Si el objeto contenedor se destruye, sus partes también lo hacen. En el sistema desarrollado, la relación entre Inventario y Producto es de composición, ya que el control de inventario está intrínsecamente ligado al producto que gestiona.

La \textbf{herencia} (también llamada generalización) establece una relación ``es-un'' entre una clase padre y sus clases hijas. Las subclases heredan todos los atributos y métodos de la superclase, pudiendo añadir funcionalidad específica o redefinir comportamientos heredados. Esta relación permite la reutilización de código y el polimorfismo, fundamentales para el diseño flexible de sistemas.

\subsection{Diagramas UML}

El Lenguaje Unificado de Modelado (UML) es un estándar para visualizar, especificar, construir y documentar artefactos de sistemas software \cite{fowler2003}. Los diagramas de clases son uno de los tipos más importantes de UML, mostrando la estructura estática del sistema mediante clases, atributos, métodos y relaciones.

Un diagrama de clases UML representa cada clase como un rectángulo dividido en tres secciones: nombre de la clase, atributos y métodos. Los modificadores de visibilidad se indican con símbolos: + para público, - para privado, \# para protegido. Las relaciones se representan mediante diferentes tipos de líneas: líneas sólidas para asociaciones, líneas con rombos para agregación y composición, y flechas con líneas continuas para herencia.

Los diagramas UML son fundamentales en las fases de análisis y diseño, permitiendo comunicar la estructura del sistema de forma visual e independiente del lenguaje de programación. Herramientas como PlantUML, draw.io y Mermaid permiten crear estos diagramas mediante código o interfaces gráficas, facilitando su actualización y versionado junto con el código fuente.

\section{Análisis y Diseño}

\subsection{Diagrama de Clases del Modelo}

\begin{figure}[H]
\centering
\includegraphics[width=1.2\textwidth]{img/diagramUML.png}
\caption{Diagrama de clases del modelo del sistema}
\end{figure}

\subsection{Explicación de las Relaciones entre Clases}

El diagrama anterior representa la estructura fundamental del sistema, donde cada relación tiene un significado específico y consecuencias en la implementación.

\textbf{Herencia en la jerarquía de Usuario}: La clase abstracta Usuario define la estructura y comportamiento común para todos los tipos de usuarios del sistema. Las clases Administrador, Cajero y Cliente heredan de Usuario, especializando su funcionalidad según el rol. Esta relación de herencia permite aplicar polimorfismo, donde un método puede trabajar con cualquier tipo de Usuario sin conocer su tipo específico, simplemente invocando los métodos abstractos que cada subclase implementa de forma particular.

La decisión de hacer Usuario abstracta se justifica porque no tiene sentido crear instancias de ``Usuario'' genérico; todo usuario debe tener un rol específico. Los métodos abstractos como mostrarInfo(), calcularAcceso() y getRol() obligan a cada subclase a proporcionar su propia implementación, garantizando que cada tipo de usuario tenga comportamiento específico para estas operaciones.

\textbf{Asociación entre Cliente y Pedido}: Un Cliente puede realizar múltiples Pedidos a lo largo del tiempo, estableciendo una relación uno-a-muchos. Esta asociación se implementa mediante el atributo idUsuario en la clase Pedido, que funciona como clave foránea referenciando al cliente que realizó el pedido. La relación es unidireccional desde Pedido hacia Cliente, ya que los pedidos necesitan saber quién los realizó, pero un cliente no mantiene una lista de todos sus pedidos en memoria.

\textbf{Composición entre Pedido y DetallePedido}: Un Pedido se compone de múltiples DetallePedido, donde cada detalle representa un producto específico con su cantidad y precio. Esta es una relación de composición porque los detalles no pueden existir sin un pedido; si se elimina un pedido, todos sus detalles también deben eliminarse. La clase Pedido mantiene una lista de DetallePedido, permitiendo gestionar todos los productos del pedido como una unidad.

\textbf{Referencia de DetallePedido a Producto}: Cada DetallePedido referencia al Producto que se está ordenando mediante idProducto. Esta es una asociación simple, ya que el detalle necesita conocer el producto para obtener su información (nombre, precio), pero no lo posee ni controla su ciclo de vida. Cuando se crea un detalle de pedido, se captura el precio actual del producto en ese momento, garantizando que cambios futuros de precio no afecten pedidos históricos.

\textbf{Composición entre Inventario y Producto}: La relación entre Inventario y Producto es de composición fuerte. El objeto Inventario contiene directamente una instancia de Producto, no solo su identificador. Esto permite al inventario acceder directamente a toda la información del producto para realizar verificaciones de stock y generar alertas. El ciclo de vida del control de inventario está ligado al producto que gestiona.

\section{Implementación}

\subsection{Clases del Modelo}

\subsubsection{Usuario.java}

\begin{javacode}{Usuario.java}
package com.cafeteria.modelo;
import java.sql.Timestamp;
public abstract class Usuario {
    protected int idUsuario;
    protected String nombre;
    protected String apellido;
    protected String email;
    protected String password;
    protected Timestamp fechaRegistro;
    protected boolean activo;
    public Usuario(String nombre, String apellido, String email, String password) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.email = email;
        this.password = password;
        this.activo = true;
    }
    public Usuario() { }
    public int getIdUsuario() { return idUsuario; }
    public void setIdUsuario(int idUsuario) { this.idUsuario = idUsuario; }
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
    public String getApellido() { return apellido; }
    public void setApellido(String apellido) { this.apellido = apellido; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    public Timestamp getFechaRegistro() { return fechaRegistro; }
    public void setFechaRegistro(Timestamp fechaRegistro) { this.fechaRegistro = fechaRegistro; }
    public boolean isActivo() { return activo; }
    public void setActivo(boolean activo) { this.activo = activo; }
    public String getNombreCompleto() { return nombre + " " + apellido; }
    public boolean validarCredenciales(String email, String password) {
        return this.email.equals(email) && this.password.equals(password) && this.activo;
    }
    public abstract String mostrarInfo();
    public abstract String calcularAcceso();
    public abstract String getRol();
    @Override
    public String toString() {
        return "Usuario{" + 
               "id=" + idUsuario + 
               ", nombre=" + getNombreCompleto() + 
               ", email=" + email + 
               ", rol=" + getRol() + 
               '}';
    }
}
\end{javacode}

\subsubsection{Administrador.java}

\begin{javacode}{Administrador.java}
package com.cafeteria.modelo;
public class Administrador extends Usuario {
    private String areaGestion;
    private int nivelAcceso;
    public Administrador(String nombre, String apellido, String email, String password, String areaGestion) {
        super(nombre, apellido, email, password);
        this.areaGestion = areaGestion;
        this.nivelAcceso = 3;
    }
    public Administrador() { super(); }
    public String getAreaGestion() { return areaGestion; }
    public void setAreaGestion(String areaGestion) { this.areaGestion = areaGestion; }
    public int getNivelAcceso() { return nivelAcceso; }
    public void setNivelAcceso(int nivelAcceso) { this.nivelAcceso = nivelAcceso; }
    @Override
    public String mostrarInfo() {
        return String.format("ADMINISTRADOR\nNombre: %s\nEmail: %s\nArea: %s\nNivel de Acceso: %d\nEstado: %s",
                           getNombreCompleto(), email, areaGestion, nivelAcceso, activo ? "Activo" : "Inactivo");
    }
    @Override
    public String calcularAcceso() {
        return "Acceso TOTAL: Dashboard, Productos, Pedidos, Usuarios, Reportes, Inventario";
    }
    @Override
    public String getRol() { return "administrador"; }
    public String gestionarSistema() {
        return "Gestión completa del sistema habilitada para: " + getNombreCompleto();
    }
    public String generarReportes() {
        return "Generando reportes administrativos...";
    }
}
\end{javacode}

\subsubsection{Cliente.java}

\begin{javacode}{Cliente.java}
package com.cafeteria.modelo;
public class Cliente extends Usuario {
    private int puntosAcumulados;
    private String tipoMembresia;
    private double saldo;
    public Cliente(String nombre, String apellido, String email, String password) {
        super(nombre, apellido, email, password);
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }
    public Cliente() {
        super();
        this.puntosAcumulados = 0;
        this.tipoMembresia = "Ninguna";
        this.saldo = 0.0;
    }
    public int getPuntosAcumulados() { return puntosAcumulados; }
    public void setPuntosAcumulados(int puntosAcumulados) {
        this.puntosAcumulados = puntosAcumulados;
        actualizarMembresia();
    }
    public String getTipoMembresia() { return tipoMembresia; }
    public void setTipoMembresia(String tipoMembresia) { this.tipoMembresia = tipoMembresia; }
    public double getSaldo() { return saldo; }
    public void setSaldo(double saldo) { this.saldo = saldo; }
    @Override
    public String mostrarInfo() {
        return String.format("CLIENTE\nNombre: %s\nEmail: %s\nMembresía: %s\nPuntos: %d\nSaldo: S/ %.2f\nEstado: %s",
                           getNombreCompleto(), email, tipoMembresia, puntosAcumulados, saldo, activo ? "Activo" : "Inactivo");
    }
    @Override
    public String calcularAcceso() {
        return "Acceso CLIENTE: Menú, Carrito, Mis Pedidos, Mi Perfil";
    }
    @Override
    public String getRol() { return "cliente"; }
    public boolean agregarSaldo(double monto) {
        if (monto <= 0) return false;
        this.saldo += monto;
        return true;
    }
    public boolean tieneSaldoSuficiente(double monto) { return this.saldo >= monto; }
    public boolean realizarCompra(double totalCompra) {
        if (!tieneSaldoSuficiente(totalCompra)) return false;
        this.saldo -= totalCompra;
        acumularPuntos(totalCompra);
        return true;
    }
    public void acumularPuntos(double totalCompra) {
        int puntosGanados = (int) (totalCompra / 5);
        this.puntosAcumulados += puntosGanados;
        actualizarMembresia();
    }
    private void actualizarMembresia() {
        if (puntosAcumulados >= 100) this.tipoMembresia = "Oro";
        else if (puntosAcumulados >= 50) this.tipoMembresia = "Plata";
        else if (puntosAcumulados >= 20) this.tipoMembresia = "Bronce";
        else this.tipoMembresia = "Ninguna";
    }
    public double calcularDescuento() {
        switch (tipoMembresia) {
            case "Oro": return 0.15;
            case "Plata": return 0.10;
            case "Bronce": return 0.05;
            case "Ninguna": return 0.0;
            default: return 0.0;
        }
    }
}
\end{javacode}

\subsubsection{Producto.java}

\begin{javacode}{Producto.java}
package com.cafeteria.modelo;
public class Producto {
    private int idProducto;
    private String nombre;
    private String descripcion;
    private double precio;
    private int stock;
    private String categoria;
    private boolean disponible;
    private String imagen;
    public Producto() {}
    public Producto(String nombre, String descripcion, double precio, int stock, String categoria) {
        this.nombre = nombre;
        this.descripcion = descripcion;
        this.precio = precio;
        this.stock = stock;
        this.categoria = categoria;
        this.disponible = true;
    }
    public int getIdProducto() { return idProducto; }
    public void setIdProducto(int idProducto) { this.idProducto = idProducto; }
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }
    public String getDescripcion() { return descripcion; }
    public void setDescripcion(String descripcion) { this.descripcion = descripcion; }
    public double getPrecio() { return precio; }
    public void setPrecio(double precio) { this.precio = precio; }
    public int getStock() { return stock; }
    public void setStock(int stock) { this.stock = stock; }
    public String getCategoria() { return categoria; }
    public void setCategoria(String categoria) { this.categoria = categoria; }
    public boolean isDisponible() { return disponible; }
    public void setDisponible(boolean disponible) { this.disponible = disponible; }
    public String getImagen() { return imagen; }
    public void setImagen(String imagen) { this.imagen = imagen; }
    public boolean hayStock() { return stock > 0 && disponible; }
    public void actualizarStock(int cantidad) {
        this.stock += cantidad;
        if (this.stock <= 0) this.disponible = false;
        else this.disponible = true;
    }
    public String obtenerEstado() {
        if (!disponible) return "No disponible";
        if (stock <= 5) return "Stock bajo";
        if (stock <= 10) return "Stock medio";
        return "Disponible";
    }
    @Override
    public String toString() {
        return String.format("Producto{id=%d, nombre='%s', precio=S/%.2f, stock=%d, estado='%s'}", 
                           idProducto, nombre, precio, stock, obtenerEstado());
    }
}
\end{javacode}

\subsubsection{Pedido.java}

\begin{javacode}{Pedido.java}
package com.cafeteria.modelo;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
public class Pedido {
    private int idPedido;
    private int idUsuario;
    private Timestamp fechaPedido;
    private double total;
    private String estado;
    private String metodoPago;
    private String observaciones;
    private List<DetallePedido> detalles;
    public Pedido() {
        this.detalles = new ArrayList<>();
        this.estado = "pendiente";
        this.total = 0.0;
    }
    public Pedido(int idUsuario, String metodoPago) {
        this.idUsuario = idUsuario;
        this.metodoPago = metodoPago;
        this.estado = "pendiente";
        this.total = 0.0;
        this.detalles = new ArrayList<>();
    }
    public int getIdPedido() { return idPedido; }
    public void setIdPedido(int idPedido) { this.idPedido = idPedido; }
    public int getIdUsuario() { return idUsuario; }
    public void setIdUsuario(int idUsuario) { this.idUsuario = idUsuario; }
    public Timestamp getFechaPedido() { return fechaPedido; }
    public void setFechaPedido(Timestamp fechaPedido) { this.fechaPedido = fechaPedido; }
    public double getTotal() { return total; }
    public void setTotal(double total) { this.total = total; }
    public String getEstado() { return estado; }
    public void setEstado(String estado) { this.estado = estado; }
    public String getMetodoPago() { return metodoPago; }
    public void setMetodoPago(String metodoPago) { this.metodoPago = metodoPago; }
    public String getObservaciones() { return observaciones; }
    public void setObservaciones(String observaciones) { this.observaciones = observaciones; }
    public List<DetallePedido> getDetalles() { return detalles; }
    public void setDetalles(List<DetallePedido> detalles) { this.detalles = detalles; }
    public void agregarDetalle(DetallePedido detalle) {
        this.detalles.add(detalle);
        calcularTotal();
    }
    public void calcularTotal() {
        this.total = 0;
        for (DetallePedido detalle : detalles) {
            this.total += detalle.getSubtotal();
        }
    }
    public void cambiarEstado(String nuevoEstado) {
        String[] estadosValidos = {"pendiente", "preparando", "listo", "entregado", "cancelado"};
        for (String estadoValido : estadosValidos) {
            if (estadoValido.equals(nuevoEstado)) {
                this.estado = nuevoEstado;
                return;
            }
        }
        throw new IllegalArgumentException("Estado no válido: " + nuevoEstado);
    }
}
\end{javacode}

\subsubsection{DetallePedido.java}

\begin{javacode}{DetallePedido.java}
package com.cafeteria.modelo;
public class DetallePedido {
    private int idDetalle;
    private int idPedido;
    private int idProducto;
    private String nombreProducto;
    private int cantidad;
    private double precioUnitario;
    private double subtotal;
    public DetallePedido() {}
    public DetallePedido(int idProducto, int cantidad, double precioUnitario) {
        this.idProducto = idProducto;
        this.cantidad = cantidad;
        this.precioUnitario = precioUnitario;
        calcularSubtotal();
    }
    public void setIdDetalle(int idDetalle) { this.idDetalle = idDetalle; }
    public int getIdPedido() { return idPedido; }
    public void setIdPedido(int idPedido) { this.idPedido = idPedido; }
    public int getIdProducto() { return idProducto; }
    public void setIdProducto(int idProducto) { this.idProducto = idProducto; }
    public String getNombreProducto() { return nombreProducto; }
    public void setNombreProducto(String nombreProducto) { this.nombreProducto = nombreProducto; }
    public int getCantidad() { return cantidad; }
    public void setCantidad(int cantidad) { 
        this.cantidad = cantidad;
        calcularSubtotal();
    }
    public double getPrecioUnitario() { return precioUnitario; }
    public void setPrecioUnitario(double precioUnitario) { 
        this.precioUnitario = precioUnitario;
        calcularSubtotal();
    }
    public double getSubtotal() { return subtotal; }
    public void setSubtotal(double subtotal) { this.subtotal = subtotal; }
    public void calcularSubtotal() { this.subtotal = this.cantidad * this.precioUnitario; }
}
\end{javacode}

\subsection{Clases DAO (Data Access Object)}

\subsubsection{ConexionBD.java}

\begin{javacode}{ConexionBD.java}
package com.cafeteria.dao;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
public class ConexionBD {
    private static final String URL = "jdbc:mysql://localhost:3306/cafetin";
    private static final String USUARIO = "root";
    private static final String PASSWORD = "";
    private static final String DRIVER = "com.mysql.cj.jdbc.Driver";
    private static Connection conexion = null;
    private ConexionBD() { }
    public static Connection getConexion() {
        try {
            if (conexion == null || conexion.isClosed()) {
                Class.forName(DRIVER);
                conexion = DriverManager.getConnection(URL, USUARIO, PASSWORD);
                System.out.println("Conexión exitosa a la base de datos");
            }
        } catch (ClassNotFoundException e) {
            System.err.println("Error: Driver no encontrado"); e.printStackTrace();
        } catch (SQLException e) {
            System.err.println("Error al conectar con la base de datos"); e.printStackTrace();
        }
        return conexion;
    }
    public static void cerrarConexion() {
        try {
            if (conexion != null && !conexion.isClosed()) {
                conexion.close();
                System.out.println("Conexión cerrada correctamente");
            }
        } catch (SQLException e) {
            System.err.println("Error al cerrar la conexión"); e.printStackTrace();
        }
    }
    public static boolean probarConexion() {
        Connection conn = getConexion();
        return conn != null;
    }
}
\end{javacode}

\subsubsection{UsuarioDAO.java}

\begin{javacode}{UsuarioDAO.java}
package com.cafeteria.dao;
import com.cafeteria.modelo.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
public class UsuarioDAO {
    public Usuario autenticar(String email, String password) {
        Usuario usuario = null;
        String sql = "SELECT * FROM usuarios WHERE email = ? AND password = MD5(?) AND activo = true";
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, email);
            stmt.setString(2, password);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                String rol = rs.getString("rol");
                switch (rol) {
                    case "administrador":
                        Administrador admin = new Administrador();
                        admin.setIdUsuario(rs.getInt("id_usuario"));
                        admin.setNombre(rs.getString("nombre"));
                        admin.setApellido(rs.getString("apellido"));
                        admin.setEmail(rs.getString("email"));
                        admin.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        admin.setActivo(rs.getBoolean("activo"));
                        admin.setAreaGestion(rs.getString("area_gestion"));
                        admin.setNivelAcceso(rs.getInt("nivel_acceso"));
                        usuario = admin;
                        break;
                    case "cliente":
                        Cliente cliente = new Cliente();
                        cliente.setIdUsuario(rs.getInt("id_usuario"));
                        cliente.setNombre(rs.getString("nombre"));
                        cliente.setApellido(rs.getString("apellido"));
                        cliente.setEmail(rs.getString("email"));
                        cliente.setFechaRegistro(rs.getTimestamp("fecha_registro"));
                        cliente.setActivo(rs.getBoolean("activo"));
                        cliente.setPuntosAcumulados(rs.getInt("puntos_acumulados"));
                        cliente.setTipoMembresia(rs.getString("tipo_membresia"));
                        cliente.setSaldo(rs.getDouble("saldo"));
                        usuario = cliente;
                        break;
                }
            }
        } catch (SQLException e) {
            System.err.println("Error al autenticar usuario: " + e.getMessage());
        }
        return usuario;
    }
    public boolean insertar(Usuario usuario) {
        String sql = "INSERT INTO usuarios (nombre, apellido, email, password, rol, " +
                    "area_gestion, nivel_acceso, puntos_acumulados, tipo_membresia, turno, saldo) " +
                    "VALUES (?, ?, ?, MD5(?), ?, ?, ?, ?, ?, ?, ?)";
        try (Connection conn = ConexionBD.getConexion();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, usuario.getNombre());
            stmt.setString(2, usuario.getApellido());
            stmt.setString(3, usuario.getEmail());
            stmt.setString(4, usuario.getPassword());
            stmt.setString(5, usuario.getRol());
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                stmt.setString(6, admin.getAreaGestion());
                stmt.setInt(7, admin.getNivelAcceso());
                stmt.setNull(8, Types.INTEGER);
                stmt.setNull(9, Types.VARCHAR);
                stmt.setNull(10, Types.VARCHAR);
                stmt.setNull(11, Types.DOUBLE);
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                stmt.setNull(6, Types.VARCHAR);
                stmt.setNull(7, Types.INTEGER);
                stmt.setInt(8, cliente.getPuntosAcumulados());
                stmt.setString(9, cliente.getTipoMembresia());
                stmt.setNull(10, Types.VARCHAR);
                stmt.setDouble(11, cliente.getSaldo());
            }
            int filasAfectadas = stmt.executeUpdate();
            return filasAfectadas > 0;
        } catch (SQLException e) {
            System.err.println("Error al insertar usuario: " + e.getMessage());
            return false;
        }
    }
}
\end{javacode}

\subsection{Servlets (Controladores)}

\subsubsection{ServletLogin.java}

\begin{javacode}{ServletLogin.java}
package com.cafeteria.controlador;
import com.cafeteria.dao.UsuarioDAO;
import com.cafeteria.modelo.*;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
@WebServlet(name = "ServletLogin", urlPatterns = {"/ServletLogin"})
public class ServletLogin extends HttpServlet {
    private UsuarioDAO usuarioDAO = new UsuarioDAO();
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String accion = request.getParameter("accion");
        if ("login".equals(accion)) login(request, response);
        else if ("registro".equals(accion)) registro(request, response);
        else if ("logout".equals(accion)) logout(request, response);
    }
    private void login(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        Usuario usuario = usuarioDAO.autenticar(email, password);
        if (usuario != null) {
            HttpSession session = request.getSession();
            session.setAttribute("usuario", usuario);
            session.setAttribute("idUsuario", usuario.getIdUsuario());
            session.setAttribute("nombreUsuario", usuario.getNombreCompleto());
            session.setAttribute("rol", usuario.getRol());
            if (usuario instanceof Administrador) {
                Administrador admin = (Administrador) usuario;
                session.setAttribute("areaGestion", admin.getAreaGestion());
                session.setAttribute("nivelAcceso", admin.getNivelAcceso());
            } else if (usuario instanceof Cliente) {
                Cliente cliente = (Cliente) usuario;
                session.setAttribute("puntosAcumulados", cliente.getPuntosAcumulados());
                session.setAttribute("tipoMembresia", cliente.getTipoMembresia());
            }
            if (usuario instanceof Administrador || usuario instanceof Cajero) {
                response.sendRedirect("dashboard.jsp");
            } else {
                response.sendRedirect("menu.jsp");
            }
        } else {
            request.setAttribute("error", "Email o contraseña incorrectos");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        }
    }
    private void registro(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        String nombre = request.getParameter("nombre");
        String apellido = request.getParameter("apellido");
        String email = request.getParameter("email");
        String password = request.getParameter("password");
        String confirmarPassword = request.getParameter("confirmarPassword");
        if (!password.equals(confirmarPassword)) {
            request.setAttribute("error", "Las contraseñas no coinciden");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
            return;
        }
        Cliente cliente = new Cliente(nombre, apellido, email, password);
        boolean registrado = usuarioDAO.insertar(cliente);
        if (registrado) {
            request.setAttribute("mensaje", "Registro exitoso. Ya puedes iniciar sesión.");
            request.getRequestDispatcher("login.jsp").forward(request, response);
        } else {
            request.setAttribute("error", "Error al registrar. El email podría estar en uso.");
            request.getRequestDispatcher("registro.jsp").forward(request, response);
        }
    }
    private void logout(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        HttpSession session = request.getSession(false);
        if (session != null) session.invalidate();
        response.sendRedirect("index.jsp");
    }
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }
}
\end{javacode}

\section{Resultados y Pruebas}

\subsection{Interfaz de Usuario}

\begin{figure}[H]
\centering
\includegraphics[width=1.2\textwidth]{img/login.png}
\caption{Pantalla de login del sistema}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1.2\textwidth]{img/menu.png}
\caption{Menú principal con productos disponibles}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1.2\textwidth]{img/carrito.png}
\caption{Carrito de compras con productos seleccionados}
\end{figure}

\subsection{Base de Datos}

\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[width=1.1\linewidth, height=0.85\textheight, keepaspectratio]{img/diagrama_bd.png}
\caption{Diagrama de la base de datos MySQL}
\end{figure}
\end{landscape}

\section{Conclusiones}

El desarrollo del Sistema de Gestión de Cafetín Universitario ha permitido aplicar de manera práctica los conceptos fundamentales de la Programación Orientada a Objetos en un contexto real de desarrollo de software. La implementación exitosa del sistema demuestra la efectividad de los principios POO como herramientas para crear aplicaciones modulares, mantenibles y escalables.

La herencia y el polimorfismo se evidenciaron claramente en la jerarquía de usuarios, donde la clase abstracta Usuario proporcionó una base común para las especializaciones Administrador, Cajero y Cliente. Este diseño permitió tratar a todos los tipos de usuarios de manera uniforme cuando se requería, mientras se aprovechaban sus comportamientos específicos cuando era necesario.

El encapsulamiento se aplicó consistentemente en todas las clases del modelo, protegiendo los atributos mediante modificadores de acceso privados y exponiendo únicamente métodos públicos para interactuar con los objetos. Esta práctica contribuyó significativamente a la robustez del sistema y facilitó la detección y corrección de errores.

La integración de tecnologías web (Servlets y JSP) con la base de datos MySQL a través del patrón DAO demostró la importancia de separar responsabilidades en capas bien definidas. La arquitectura MVC implementada permitió un desarrollo organizado y colaborativo, donde cambios en la interfaz de usuario no afectaron la lógica de negocio y viceversa.

El sistema desarrollado no solo cumple con los requisitos funcionales especificados, sino que también incorpora características avanzadas como sistema de membresías, control de inventario inteligente y gestión de múltiples roles de usuario. Estas funcionalidades adicionales enriquecen la experiencia del usuario final y proporcionan herramientas valiosas para la administración del cafetín.

En conclusión, el proyecto representa una aplicación completa de los principios de POO en un sistema real, demostrando cómo los conceptos teóricos se traducen en soluciones prácticas y funcionales. El conocimiento adquirido durante este desarrollo será fundamental para enfrentar desafíos más complejos en futuros proyectos de software.

\section{Referencias}

\begin{thebibliography}{99}
\bibitem{booch2007} Booch, G., Maksimchuk, R. A., Engle, M. W., Young, B. J., Conallen, J., \& Houston, K. A. (2007). \emph{Object-Oriented Analysis and Design with Applications}. Addison-Wesley Professional.
\bibitem{bloch2018} Bloch, J. (2018). \emph{Effective Java}. Addison-Wesley Professional.
\bibitem{martin2008} Martin, R. C. (2008). \emph{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall.
\bibitem{gamma1994} Gamma, E., Helm, R., Johnson, R., \& Vlissides, J. (1994). \emph{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley.
\bibitem{walls2015} Walls, C. (2015). \emph{Spring in Action}. Manning Publications.
\bibitem{alur2003} Alur, D., Malks, D., \& Crupi, J. (2003). \emph{Core J2EE Patterns: Best Practices and Design Strategies}. Prentice Hall.
\bibitem{bauer2015} Bauer, C., \& King, G. (2015). \emph{Java Persistence with Hibernate}. Manning Publications.
\bibitem{hall2011} Hall, M. (2011). \emph{Core Servlets and JavaServer Pages}. Prentice Hall.
\bibitem{oracle2020} Oracle Corporation. (2020). \emph{Java EE 8 Tutorial}. Oracle Press.
\bibitem{dubois2013} Dubois, P. (2013). \emph{MySQL Cookbook}. O'Reilly Media.
\bibitem{schwartz2012} Schwartz, B., Zaitsev, P., \& Tkachenko, V. (2012). \emph{High Performance MySQL}. O'Reilly Media.
\bibitem{larman2004} Larman, C. (2004). \emph{Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development}. Prentice Hall.
\bibitem{fowler2003} Fowler, M. (2003). \emph{UML Distilled: A Brief Guide to the Standard Object Modeling Language}. Addison-Wesley Professional.
\end{thebibliography}


\end{document}
